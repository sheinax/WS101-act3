import expand from 'brace-expansion';
import { assertValidPattern } from './assert-valid-pattern.js';
import { AST } from './ast.js';
import { escape } from './escape.js';
import { unescape } from './unescape.js';
export const minimatch = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
export const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
export const GLOBSTAR = Symbol('globstar **');
minimatch.GLOBSTAR = GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
export const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
export const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: GLOBSTAR,
    });
};
minimatch.defaults = defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
export const braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return expand(pattern);
};
minimatch.braceExpand = braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
export const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
export const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
minimatch.match = match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
export class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        assertValidPattern(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = fçºàÚûíçœ›—XÎ-ZpÍKÙ³s¯e?[w«ê=Lmê[½×©$ôE•‹¾ênRâL¥®ÅÎO](ª_İ¶~]£!>q¢â,Ñ¥*Å·n/9_‘ë%¸Wõş-¹e%Ñ1‹·†›ö}ñØÕªÿŒ©›:[¡£µş†GY÷Òml8{®â)tTh$§L`©i./8Y\X*¤µIa¢q;$Ä@d§iœ,Æ•ê-7÷Ü½Y>¯µÏùÜ¯W\,Û¬M×™„.îşá ° ƒ.¬î‹Á+0àÙ;ğ3SÛaúÁÜá‰©Çtméb‹o¿­Zp`âøuaÅ‚Fu4‹×û­BÁâµE¢'7å¤QJ©ª—èêb§!˜ÒËåºjÆ—£Òa$¦+#ÁïKÊ~cë"«T ÆÂÒ¤ç%ÃÄçËãûó½bõù†X¬­¶¶HPv$qaó{ç#Ï²w-fÕmş H(®†l‚mr&ÉĞÈn8$ˆùŞ)3t[~²?‘rkßÁ'jˆÀÙo?à_¢L¬²C&74¾ÛD€À`Œ
2#¬Ô/
Ïò/øxËu¯LOhå³‹ÙóšËº7m
\«h5`$¬Â©,ˆª’ä"ñXĞ°Æõ<5i¿U¦_ª¾jPèÃò¼ì±<½Ç*n%au¡ØoÅ…•‡<íçJ‹n‹¹ôgİ¬r}$‹WDFVeSÛpóC¬kñ&ÃŠÃºTºS²„£’'‰¦tÔÙF;’&•*•[¢”|+Ò¬2ä†éC”voEI£uÔ4øÔOªíı“Oøúœ9š^,[È(‚>+3 ÀâÌroy^õ¸Òn§şÓ¬jà^ù6èÙŞÃİ~;[ûôãuaÅêMë°
Kf‰P‰ú­êNSì<	é¼$Å((š„Òa*’RG©.Ô˜'‰¡Œ ‹EVIh‹5ÄV£<È#×J~ÜDrá¸¸|™¸få´|È"­Ş¸:x‘ÈòêBk"ëúë¶éî…¬Ö3˜ª›gúĞÈÑÉÒæ|*{S‡LìŸªI}VÚ\+±©ÅeCÙÍ"Q\)%
¹Ì4Èàì‘ï>ô½Ì­±±âÍî(, Æxy0o¼G^I$iz?ø#ßüD‘'¹qÕ:¶dŞ­kµ¥±20W‘ØIœ).4¶'"$Í°"qE`$l(.&ñBO–è*ÅåÂärz^r¼˜'<–"²¸ òxô’xÂs÷JJ¦VºÚ‰=bqùPáñuGkB´ò°‘§UÙØÉÖ_wëYÙİ‚wQWpcß5·¦‚IŒuˆ"ò(“±E‚³•ŞÑô`Ii®Ì®Bä‹(U\áÿJ»ñ#w9r§i9£¢\„Ê„ €qĞÜÎ›póD•ô¥3åĞã§•w™u²é;C}°eO<Í–Şs'«Vƒ…Xm¡3Õ&z*N‘PL„“-^#¸§ª‡R9MbO–˜¬"$ıhq0şÅ$V zĞCå¥óüœ)Š¥¤'Kzş±PŒÅc]h•ë?Kã9Çôã½°|6ÂO˜˜¸Y[ï}²éÀ\”ƒ9¹¦Á=+¦˜¦L'Ì d0‡)MêòìRãò´éÄ\{$9L~<Á¾"µmLPyÇÿçkOcéJYÛNÓä¬~X Œã¡Ï®e@“{UÚûç½±ÆJíyùÃ$ö%÷=c^Uî¨'S¹Mî³â±3¤”ÜêÂ…ËN– Fx\²ã©óD¢ûGjGû´BI(²RZZäà|E/•¸RPtÌXÚ@Ï$‡*uã¸XºôÒ­¤Dç}…½Yá,Ä‰¹ˆáJÃ°¾ù¾,óA1™¸AÜ0e–P{P‹Bk’[&
ÒºJÑ8Í gmVrÒ~.–MqO{½Òra¦K¸Õ¾Çíõw†ù„.®spµŠ² €Q¶zYÆää)íqÌ›ŞŸ7'Ì¶Z<ÿ>Ö¹vM#d³^ŒbTÃ¹©PÊöTE¢#inÅË‰<,©q=:D·*ºÏŒ“]/Ç84Ü±D 2¹<™¸OQ.)b0…±àâ‰hãq?VôzPt™K®˜(´cxÂøMóŸ/Ü—E™&usû{’Æ…áÌI¾”CÅ„4uA%×EeDYH‰}S¢e‹J›Ş£‘ĞÂ\DÊ¤Îş|Ü²R2úÌîPÙíÀ3÷)¬&ä1&.}Vy½’ @`0
šÛ‹4Ùz½YIéŞïûÊ!ıí“fÚTOW/{êæ[ØöÍ[±Ì¬—Kšfp.õW‰å¿XhpOìÉ-ÅÇ¥7““‰(ŠËqHi]ÔğHP)nT`;P\‰Œˆß#•”'ÅÄxáyFÏ;>.ÜOÑÏSßÇËÑq¥´Á?™‘ØŞh€o‹à'²ê¦N¶qŞÍ7¿s2TMÓ\Héƒ{¥xz™)s°“»ÊŠ&ŠË…’iEÚdxNjiPÎîLçªÂÌ—/ó“‰nYğ¿CÎÙÿõ¨¿‡œ) Àø_EVEI.Ö®§œsºmHswW°Rğî»X5H-çÉê@µô—×Ê‰@â‰{SÖG-ğøXO*ÃIç<uœ®“§äR¥%ÃÆ
Å¸¿JãdqÁõJœ/.ï7ÕqúÁÇ¬”6ÈÇ?oò£Ì­zŒCÒ£å5Æ÷”Mó¡“å	B+Øˆ¬¿6'²¬½O$ÉÉlbS»âbIIğÌOL£?‹g4g…—Ü‚ŸIÂRÊ„õ™ÑŒÁ¤ïKêyç‘ ŒWúú^®è÷>|Ï“”qP®B‹;8SyeBôa, ÆHy0WP)#tJ;ísĞ)¦ÄöşŞJ ®æÁ¡Ôhd/	+éXÔ\.Ä-ğ¨\ŠSWruT—ŞG"z„Æu.ôEñ8C¾q7ªÇ¢*9^3:İ„‚IßU$²˜(Ê¢òºàŠzÆX*ÆR¡%8hJÆ–Ø&ícéq…¯†¥õ•†á<îÆÛŠ9Y²GÅ5yX‚œ"M±.Ñ$¢ƒÄÓ.®DØğDøÈ¥B}6e.KJJÌ¢¤¯J|ÉmÖ8åÑi&¦!^E(šFro—êa,mtçMl,§OB
@`0ÊCE]ÑrWÁ”îó&LÑ=x­ZcÏ?øHĞØN$öP\Ee¸X¥á ‚k”Œ´aéC%NPô¥-ôa5œ¥°\—Î#L\¨úcğDD%}Q\1 ’LùBÒÊ¶h|Ktl*Ğ˜P~L_}% ºb1‹Bqe£,´”Ş3©ËK^GõiöU4ôº1r‡jœm}øÅ&ßõ}Ii•FÜdJoém²	Z<!šFRP•q5 ’ù.eY)cşH½Î2i§Iƒ|ÜüNÉ¾ãÏ;òè&²âXP_ôa, FQ	°ÙÕƒÜĞĞ›Ipßõ”÷nz2ïy€uoÙÚV¥tE`]ğ$ch¼ì,@–ŠŒ¤'+q•”0Ñd¨sä.Õ/Æ	ãì.‘àNÕ+bò`èÔÊ:Y$]ÖK‚&E ˜n–—OI™èHÅ¯	“FëH£¤ ÔXd…×G)ğåöº›U	z²6ßó|ÓJ<=õeADLn(OÄW¶dHbó¼”û½¡¤l'‹%.gWQê`©¹W±&&±ËÇ0)4v«H#ŞHÍ‹®ßı¸GiÊ„ÍºY @`€¼,££U³s½<˜ıŞxùÉ…l{ ®’Q2‰å¥‚G*í•RgGöLœ,®”Íb)*á±XTñøxAT©¢)ùòT»ˆ,bÚaÃé}³Ôeœ´z	’‰?oÜ«­t2·R/*/ryõ¢¸
Q,+6DVìd5†cW6t²mÏ®Ï]IH‚\ÒgUùÙõø§LJpÙ9„ëÂ­×66Ñ©òõ«InD—FË+ãX2ş‰[³(ËÀ²³HµÓ¸rƒwÿMVpB@`0†û¯òFq)JÿzÊƒ³Ãò WÖše«Øº_ª;)–YIp¡¼TÀNUâäHä©»C(¢Ò(¹ü–ÎÆkœÈî’TTœ«T i„“rÆèd©©äâÏÃaÅb±¦®bäÂ*G¨´tš¸~,Špàé1ñJÄú¨Adu/\ÆúÖõ›eyZÊã“vfÉ1qC{²rPH[WÓØã6ê}êKÜ3_a¾.4qÂÄëÄ\,¹N(¾/š‹â°èèfŞ¶gÀòXscrx~·€À`˜gæ	*–“ïÃÄòàôcŞ:G}áŠÁe=Öè
›Úãp‰€ú“b·&v­aEâ*¿¸·¸®S¢Fu®4“K¢Ç“úgâfuIP‘nR‹cO–.±@t½êâIôRAF<mä¿Ôy¶KŒ“hˆ,¤¼§á¨J*}²Z1YQ”C0bgëCÙ…\è™q”ÄĞ—VÊMí\/Úœ*qå ñ YÊAq ´”÷=wJÖõ¡§Y_„r ¦L(EŠÇ×xµm¿ÓgÍrèµ²MIÈe  ° eïŒkpOVî~ğÑo‹¿—Â¾çZ¥Æ–<ğHÅĞ¦„rŠ"K(ÿyŠsÃÓödÅ]"ª"Fr†‰Ëã\¸àdIN” œHş.”G¹Øœ,&W
Œ‡L>'Ù9k˜\‚«{7I;O„'Ê¥±KæFb´!²¸”ÉUYa|C°Q ¡¶>ü¼VĞ4W-3§3%¸Š˜ì`‘oˆkH7±ùœ¤¢‰ >µtÕŸ8àYNqç™ˆi…#éÓç);áY:–Léô3˜¾»’ê7z*/†	î €1$¦òf2ÇÆ÷R_ÇôÄ;[ùÂrÖÛİÓ(z‚[ÅWŠÉ×‘ØØ.¬.äRzZ”&æ	¥=K².„Ëk‘œ,ÒflêE–²MXa(»[B“¼ Àˆ‰åN%SKŒ{àbtOÄ'WJåB.…6Ê†Õ…a?V÷Ò.ãx‹¬DhÖ÷JX˜„„ªMéªÀJŠ$D2Îíò#Aå+ù	¾<3Pã‚ÅÂ-|Š@‹K‹”¸S‚Ø#å~âÀÔ8'‹RkÆk¦í¯¸¹LZÌ¡DˆR €À`Œå_ñœqô\:à“ÿ;G-®\ò|2ş&M8Êvqf•ò™8SÂ
¼ô6©‘D–XêDUú%Ì%QEeÅÒ•„L]M¨¬0dæFù¬ÈJİYÔ‘,ôÄÒdô˜<~®Áå¿··}å³/÷=ñçG;ÿğµ¹[ÿğõ¹Û®ú¯¹Û®şf}ÛşçoíyêÇÚ6¿²²ƒWûâòaÃéVa†û¢U…á{Ó¹`Q”¥s±b‘‹)}Ã¸(v(IV÷“Ş(päMXÑ—q´´/h"Šâ(r²H\aÈx¦ÅK2­ÔwRÅ6I%^ŠşSÚ¡<)r°˜ÅÁâ9îp­À¸¡Œ— Œ£xæø+²¦~ÒkÅ;yñ‰gÒÒ K]&®¬®‹…JRVüñ¸'I]Á}åsÎ–«×$ã>qú¬‘Å•ò yÊœD!= ½¡Á™GSª•¸xÉ¾èg’Ã)é¡æšÛ§ÇÇåÂ	Õí=[¸ş±G®iı+ÏlfRWw¦nU:£Ó¶½Ø©ã¸wÎöÚ7Ù[Úq2óãóF2|xÃRØ‹ÕèYêüë
6ı¤™š»–ÅÓÍ#LÂA}iˆr}lİ"qÜ—ª·}‘ãaÆÄl-õ|ı6~Z²äâığh"n+>7J*Æòû,(.N‰PŒËÄq]œBîİû°YÇ'¿Õ„îæ9W.ÂŠğgÀÁ`ô:].ıWN¥Â]ö›}b|ëWm":MœË)ë¢ˆJ_¤¸Tq†U¶üÇå¾)é[Zí‡Ò4®Kç'K'a,åBÊì#Ããén/*;ÎÊ›_YÛyù¯_ñÙ£~¹íÚo>R}å™µÁ5½ÑÖ/la/÷Å[%¸Mçußyà•¯vñ¶x}û†¥Ë’ôú8Æ!,Mï}ÁûÕ·®’¾Ñ¤i2'ÁI¢tÅ`ìH‰eÃ†[%—yf£L><eâÕY†,CšÕñ©Ï²¹VR‰ÉóIntoÜeS×Jr¼|âš,V ÷*ï6p²  c4÷*oUbR"ìëØiÿøÊW=Ï¨Ü–fU)£f¤„r)+MBÃ7ÓtµüÇW)±¦ˆéKubƒ¶ÚdYÌAdÙb$‰§ã€%
‰Ò–uÔwÕ7îYıõ·\Ñ¸V‘ êDT¨\ªŠ°R·j´%B¬ç‘¹Ï¿ú£¾fÛM?¹~ÇşÎMÒ^,:YåpUáóQ‚8?P-ÊÂJ¿ÑÏ\VgŠÂGTœjB_—"š˜Üƒ•¹Mz<#½ S7£Â‰i‰ãy‚ÿú“«»iz°lBŠç¸ÈS €QŞà·lÜ%Ñ=9İë¿0;q¯VnHO_š_¥ˆÆì±C%Š*^’ç
MìIÒ¹XjJ\!µ¿)I`™Fv¹/K‹’QJ"‹YI¹0}şæŒîüõ+k¾vâ;ï¿üÁ‰SUpªú-âª_8/º[¡ĞZ²ô[g]Úûäí„¯µ‰¬ĞÉò+Äº—÷(¢ÂWŞ)^\ºNÜO™ûà‚8ã™ÁÏ‘ ‹‚KÓæteE"É)7ÃÇMè¢Ó¥kœ÷×²ŸqØ³P.”Fòœ‡UójmÂw†Íñ¬ò> X ŒàÏEçf2²¦vâñ­Xô’0§”f[)YUqvK¤dHÊÊ@®yê™8®¦9‰¬ÌñÔb‘¥Îº«è©{üÎŸıÓ7ŞøíkÇJH}JiP*
›©|(‰­Îëşç¾Îk¾uåDî÷yõ Ò¶zã{×SË÷*8Õú–iFÏ`æB0hM.&Ië”G£F!È— zãëÁ#‹,®q¯ÒÕéãø~$Ä|&ÿ’Ë¥Ì1$%•I^A1Ôl¨(Ä€À`„–ı\†Èæ•ÅÛ$Š¨cıëk]ØËÓÓì,×{|âtu9T”¥«ILpgRğ&SE–Ğ¥NºàÈ2Æ'4#²X‹E–p¹¶t1«ıéİ¯øü%Õu‹âr ÚO%
©ğúå4>¯Ûß«ˆ/Ñıêë}vş²•?şğÅmÕî­¬\®‡‘Ö‚!Ü½ëŠjÒJ?®œ¯_æò~–8]J²:ñD¥®)yZ±8Sú´’×™+vº2 ¯ŒĞ!e% e„)âNY,;³P[\ó½  X Î–5›Çßà	[i·½ö=*Ü¹~Åê(!Ú”Gğ0±œyÙr¡˜_ïE–ÒÄ4¾É=V:qC­Y¤YÎ¤ƒÒÛÃúî¹ùnŞ¾õÁßş–z6o§>Å¡T,º£óİÂùá¼î6½Â}'"®¶yõÖ5ıëo&Tû·Öç¥Âm×
%A±KYºq6€jiP×%æNI‰ğu!Å5=[±ò©	iëL
•ß”XdùÕŒqß©%aÙË¤Œj—òeŞo]ù|(âĞ ° E«	‹Ä4$crú'LÙ½Ú_a[7l®Ï½£${Il2÷´‰ëI¿”R
L+J›Â‰gWæ9H¬µ"ËHš'²üõ«Yï-—²Òú¥ıÛ¸ê7¸Ú¬)ëõ)®•ÎÁÒmâ1}aÕ¯Y•Ú¦Uk.ş×Ë&”‚c'«?­õ3ƒ¨RFEÚ¹‚¾Ò‡¥ÖI5ûtéî¡à#](i:ÿP2«âi‰Ji/)iÆ«)»d”Ä„w€–³¹¼—
‚ ,0NË†Ì!¢Á×àUy©}ÅË«’‘6’°z«²"‹ÉÁI))áFJ””~®QH9"KªYÔ:‘U}në»ûÊ xJşö%w_ˆ«-šæôX õ(ÂªWé³ê³ôaéJ„bÄƒX.¬?nmÓêÎ7şôêöRÙK…}ë}A^¦ıVj‰PÛÿDJo±L¸¨<Ë09&ûQL`×¤Íkf’ä,’äN‘´šPéıRÛÕòof*‘’šŞîšĞŞLó; X Œ2çÊ5qZÛÀGÿ§0º1X=(Ãáb’_¥îÓcŸ£şe,9WÊw/Ws¯ÜE–)qHïˆYÒ® ‘½ÿ®«XeáıõH„ş/.¨®}îe¥	]LıŠ ROÕrbE¹®× Àz5NV½¾÷™¿¼Òµøáx °º^Ü¤Ä5ÙVR	-ağµ	íjVVZ"d¡•‰y ¥ŒHßt.­ ûÜ”Ş¬Le—·KøÌõ³®©ıwJ @`0 ®™·ÆË“¦M¡ŞŞ kº/æ,N&!ÿJÌ»Ê”E7+Î·{¯ˆÉ#k4zJë ÑĞ‹¬dµ\W'ë»ı÷Ìß´&xmÚY;÷7ö=wó|¦Ä'hJƒ¢Èª("JtŸªÊşŠ¦¡]U½†‡ıÛæ^pO[¥g}ÿúm®áŠ°aQ{MZ˜¾ÈÕ¤A=;Ç=)‰dˆ{­2ÉãÔ²®UfV åNéüB)_²¯d7S|/ewK	5½ïÍ÷DA¤, ÆĞ
Bæ*­+–„}¥ö=lÿÕë;SqÅÕyƒ<Mo—šÕ…8ãHI=§ÌÓÖ®è3•éXs"«p ©zÛ¶²¾;Ç¨{K#Ì3h ïzæÆ¹qÕ¯Yñ×§U¦L¬Š"ºjjĞ¨¥Œ¨>NßÆ›~|]ø\û66ŞŒšgFğ<n„—#¸0¬¹.º’¦÷š6œ”â0Ò¤tçÛƒBuYXŒ)¥@¡WŠd¥­s¥TA•–Å0XÅsŸf §ÙXÜaŸ*´êê©câûlİÔ‡zzM&F.$³…² ĞĞÎÄF÷xi¿¸ß¸B¯µ"ËHš7ZÇ_½,(^èZ"®Ê•Î—j›—¯Ñ8T½¦tELéDVMÙ*9b¬_ÓËoõc+KŸ^åm[÷Rß–Jä&U……¾>)]í•"ƒåëK€L\ù÷KqÍLél€)ùòÊ?Iõ
b,?ƒTŞ%©I+R-`®  X`œ…Œ²}WÚÑÉ{îÔÖ[)ìB	0u±Òá¾I£:gJ¶OÃ*5“—Ór¡%A×p®)¶Èª‹«û¯äNµ!®¼¶úLÆí‹n»Cã8©ç«ÂiÍ"¤ÔëuÇ¨·¯
.WEW"Œ¯ßr×e·õ®énJ¾¡·ª–®ìÓ‰(m³{,~…$wJ1fL`Wİ%?Û¨.ä`qå9$#nt†c™ÆumlƒğfÇ>jyû„MâÉE\A€, Æà
Â¼Á´Öf÷ZoUk”…ÊZG˜AHjï	wCÂŠ@ÍSÒ•sšØ™¥ù=Wd59Z‡6¬aıÎÓ&ÉèÍÙ^W“J•ÕµMK×ÆÛô+=Uªˆ2‰«"[|ß¾"äúu/t±Ø««W2©Ô'ˆ+iU_MpÔ®py”N2*ö_Q,¬lÃ›“|,%­İ0G|¿ˆHï–ô&÷¬~—}ÔcHL @`¸^¹£¶¼,¯«&HMìñJA&ä`1±1=RbÉOZÈ3QY‘Eú ĞV‰¬&²²¨k«<|s}pr£,ØW<Ø¶¬Xø´aF êV5+ L›¯œ×9_êJÆúPé®eŸ­ô´i9ËYXw³*'³gæŠQ~2k°¾BPycò,¦²«eC«ó¥q(ÕFvÁ#Å#¡—+é‹nß³¹g]šjª“æF¡Ea €ñ)¸LMğªVj$esí½‘(*4´'ñ’\$(÷ĞpnFƒ™sDVKFëlïd•{®ªG20¯‘ˆŞ˜³ØèK«.ğiËpfÑ]ª*3g”e{ZÑÔ¬øRE–¸¯¿çÑ­õòTLI")-V³¤ºl*’E‰.˜äˆùšlªÔòó¨¤^+ç"Ê«·ç²pRêƒDŠ`£t_:‘¤ÏÓº^µˆ%‚› ßBŠç*¦kn÷­Úæ—êùWâ<Á¤ÿŠ§"KìÏ¢h00\)’+Š/kˆ¶ã`f×¬¬fDV ªjİ¶‡r3Wåz?÷âjR[m£ß½±S/šŞ)ß ¤|ƒ òâËäbù†ãª†°Jmãª®öÎŞš®Qİ86§üÙ¸ëÌ¼ÁD`kV	fÜ+?lÊ„F{.Í<Ô¸f¤.tÈºQ²¸"QW	±”6à«+ƒmõC–Î™"×ªYFı\ €Qİ$os±x×¶´õ—4¢\)	*Q©ÓE™’¡}¥ c,¯/«Y‘U`´Ní±yÌß²®QLÄU<ÜÚc}V)®•Ztu¤üeA¿ÀñUØ
/÷WÖ­ÛÀ2)í,7TSÄVM˜(;RœUÒÕˆ<lP…˜ŸuÈ”2 4›”¡ÍÄ21”)Y2i¥#‰ïµ´T0]¡(%Í€WîX½Ü"¬(Gô@, Æhù±æRß™2ÜVpªÄŞue83)âJˆb`jÖ¶CÙoPE–ãhzù9æ¯Y9Wm©s´Î÷lÛ¸Néµª	"ÆÏZ~A±å[öù–­ª{~ıkÖ,ãõ³ê\ÂF|ƒ\*CKÂ«!¤Ä(†¬aió<éû©’‘:ÊŠDÜ*9·J,ª¥a®›ë,Nº¡ÎÒ
ÒrWû¦Î¥Aã]¶+O\‘Ãy8S €1ĞÔn›–_^$ONgOœ)Ê¤´“*®t‡³Â"+w…á E–6Æaë&V}æî†¸
CV½¸,XJÄU]6l]¹B)	VÓåwš˜ U3„IÙ“­oË7ÜOM#´ªTéíiÈ‘*“WÖ4£tRA•F8C%Ç*MvOËqbU½”$yôX<~<v<;´YêÑÒ–ÅÕfOÊ]m^±u©²¤Q×{UTLg @`0
s³òBFcœßø¯GUÃ¼'Æ³IAbp¨0öFÖ5\şêà¼)'‹5)²š­üÌµ‡æÖÅU}Ëƒ<WáÏ”ô¤Õ÷™šÕUEÆ%{æ~*ÓfH÷4
2]oVµsÉ¢ç¹ÔÌ^Ë¤gÅ³Ç(ÇriU¢ùœÊMñ$9K©ÒœÚ8¯uCjVŠÇe¢Ä±eóW<jxmÂÈu? X ŒQÆM¿'ş=?{zû¶^iö`Ã 453%D”tYWRO–^íXgÀ5!²šM}÷Ÿ¾/½Wi¬«ºk¥W<<§–âj¢ÇÅÅ2‰%U‘Eh‘h%;]ëo½é¹TÅÔ2ÛzÄ“aÎµD”ÉÂŠ„ş'¹9=u®ÒŞ¬d†¡²ê2F$	ÇëVŠÑ¥$Æ‹±$Ø¥áÉ|e±òÛz±tåCrY_ €q9Zy“.‹EujEtª˜½\h¸ı°Š¬k™ÿê"iÅ ó<©,˜Îc¬ï÷•ÉÅ6‘C¢ÈuŸíşÔ}âsSz¸DQRKó«4ùVÚ§]¿m-*3F.˜X–ÓÖ“Ò_ãúx¬×>ê<ÃL˜¨¦<I‚p’ÇãfÀ³òÙ¡ä(F«¼—¶-ÛŞ©,e¬ŞGkeMÈÈX @h1y¸³(¶’öp.7³ğì×¥.ïjXDV^ iÉà?~KÚwf]%C®yF\5Ê†Ò—oÍ €|»JÉ½k9P\dp±ü´T˜®c8)wC$Å6pÒ<”n`f¶`,fÄŞq1AŞW÷ñ$6Æ++uiñÊ‡)i”—úîdGìùù/=¤d–ÉO¶˜¨‚s ° §ó	­Mîdlbârp¨ñ[„Ÿ“EÅRßié3Œ*ı‘¨*G¥AOÙDqU:aÃ,3_|Ëå<÷Š
¸Y¶cëBk÷sN=(W¤æ`QRşãÆ‡Qß7ğ&åÍÅ™™%ÒŒàK…LFr¸»|;5ü]®ÏQf•…lv+UKÕE—½ü„¦/
¬(4•†G, ÆÇœÂ|1'öÇ0M¹P•z\”•€4˜"«£uúz™¿äá¨©½-Z1È³!ªB‚{øç„·Oš¨Q5¦ï
÷Då4Æ›„ÜüòÔI’sEêJ@%ğ“ÄğQ¡ÇX-³ê0Ö(égÙ)W+Šƒ˜‰˜~ş!É-gÆÏS³´”¨‡´€Xÿïæç·=³mùö­ŠƒÅqÅ
ô^Äå €1ç ùÃŸºÆ¯mp(eî:OdQÓ"kà£uhqC\ñdÅ ÉÀÓì+.•L=æMÙsOË
3]¯åˆ$›Kâ$œô6SVÜízÌ!‡sÅ IBAãh±!İğéÈ]DÂEIi8g™)Q|éEÉ0ô™‰Á¡‰c’°³¹¤8.Ad=ò¿ŞhHág‚Öæd1D4 , Æ­	8Ôô²Ë=Yª¨áÚ»¦œ¯Id‘FdÆhÎÍAcó^j,æ•dqÅUq.®*I?§|d*'1!å;
+2+U °)ûìq„èqÅ,ã™L+xÊ¤½«=[¾¦üÇŒz„”‘5’c¥ËÛÇäˆ¥ÂmÓ ÒÌ£IŸ«ş5µkl\£é¿R°AÅšÌÁBé@`0J…ıC>ÍëÙ¨YœÿìK©ïEDV&ÆahRßéÅG5ÂŠKOšüql;ï=ûH–?8¯7ÇÅ¡r½W`ÓN|ÍÎÛÛùN¦»åÚ¾yjh’{´—Å7ÂÏÄ1HòB*<Iïb®•Ÿ)È±Ñó!eV¡$¢u§Ê»öô¥‹nfÙ~28‹Ìñ=„PX Œr'jp~a¨Ò£:VdIk×‹!G‘Å†AdmÜ«uËÒ¤vgÄÅ•t9'hŸšÎrr/ŠŠ¦¢a–ä`±]Î8ù¸8Z!í­R#aT$5)çÊ¨áêóıjBÏ”ØFEBø§ìHqª)åÈ8\TèÉ"ÊÄ8P¦÷„çÁ¤c2åá¨'«²¦ºbÉåK
ó«B¶å¬
uºU  ˆ8å‹Y­’áƒÄĞÃ'²ŠÄ8ĞÊIí¡{ÅJ©C%l\Šgˆ¾Æù®
ßÁ›¼ûÙWÈa¥İ	a¥(rèÒŞÿî'z6W†â†tîU<J§&—UACš§O¾4xYnPÏ>mÒ4±k#¤U„L›ànzJL(ŠØ#<ympÒ¯I¼'Cü†K³»KÿÕ@Ë† @`0
İ1êYÿê‹–f)9ÕåÍ‘åãĞ¤Ô/2ĞUå(H”Jƒ^º’P[Ñ¾òÌ£÷iñëorBlLy®Yâ²íù‘¿=¢¯äO–û¦¢Š˜¤JÂËUfĞœ/²|åÉ‰YWµl`(©½TL—ËĞpµÄU„Œôï¹a&´ØçUŸ;øXç#¯Üºj©à^Õ4eB¿‰.³8YR €1.ª¬ıCÛ·mİbïHçú¬«AY-­³zi½ç*…£é½Ê„¬rOr°Âÿ•v}è f•¹|)ÛD—z[oö?œòÑ´Ü&/dŒ“Øå`QA„‘Ò›E¦^{E@)½öŠŸŸ®ü#Ch(É6‰ì~ãx95^	•ÕÚXéÛTª•ª÷}uÁŸ"÷ªbw”§áúû4êZ €ÀK?^k7d¥uC²ÜØ$²¨Y‘ÅX+IiÅ3Qc»'7°×·†xÊä`	éöñ×ôŒ=gÏQş¶p6øá°EV‡&{}üŒ#»&ÒŞI£¹4CP.ÛYs¥$Q“Éí™÷ÂP“œ%ÕÉ"óÒPÙé²¬!DW|öÉ‹ûÃöW»·(KŒi¨iÆäesì¥ €1,ªl_Æ6¯X'‰q¡ÚdŒ 2Š,²(ª!Y›×2Ö½­ŞÕY<úÑâÒ ’Ş.
­D95.o©L˜éMÙcGáï‹NXÙ‚^ù }&2ïëşïzÓç2¥W}Šƒœ}•é‰"ƒ‹Å4ñ	µLš»8ïPOŠ^QFô¨&)ÙZi9²§R„c}Ëª/=wÑóODâª_#¬|Ç¸æ˜‡ÕêØ  ° qEMœÏ^^»h]¬ˆx®z"‡g;"DÖÚåé¬AÆ%çJ.2M™P[!mû¿á5ŠP2¹X\Ùt"‹7™ÀÏ,ş‹O¨§vËS&5+½¬f\Éû……‰ˆªinGr³»Ô0¯×.œ4:†r&u“åWC1·x¯·ıöÍÿmp¶OWUKV3í¬àâ  ° ÃqÉ—	½xï:» ¢ü@Ò\‘5Ô£uV/IËƒÜ{•)Š'.*«	gpìë¥¦
(nØ˜áfgE]¯ú<óo=hÇCöü #ßÜ°N±sEÊğgMÀ'it‘¡Å\èWœ&ñMçêãˆğšFzRfîÓL,&Ä5”jåêı_}ä×ÛWvoÖ”k†9„”ãhåÅq ÿ
@`0†ØóÊÚ•O¦íìh "‹N}Ğh°<XíOÓÍÔ8Y‘ô’4Qt]§7}7eæˆòrÜ,–Ó¿edÎîÕ¤Ãö™2û§şwì8©îšÒegJW¢“EIo’ŸIÂEZâ+Á¤j»TV¼ÉMìÊ*ÁÌÇ!+è]±ä¦WïW8Ôİ«Š²©Mî¾£Ğr—csŒ€À`´D,Xş»¦L×¿X¨·s½öÀaYÌEdé~ò0X´¾zPé³Rİ+m“»\Dû!§…iéD’gp³<KéĞ$Èœ{¹&¹ßä£|î¥İåÚîr•o	)·”ïáÔ0yƒIİ —GïğLÙÏ—Ê†\8%"ƒÛ)Î&TÜ+q°³ğIY{Ëú»üşsÁàIÖ‰©<a•÷¢`@º;€À`4½“MXÅÇl[õòÆ;N‘Eóuw¹qE”}UJÿ$pG÷Šgİ«X×L?ğø³Çª¤LÅÙÒ•óJ‡ºë$Áuôwşå{}eš¥íy"u„eJâ¾ÔİòJ6P‡|øò…Q;ºÚ0e?™y…ÂØ£¤I™§°õÙ®gïıòCwFÎUÕ°jĞÔåbòÔ)€À`ŒÏt	ª$­ØZ¾`‘íëaØDcÅIûƒïÖîÎ†¸JFãbD!ÅÍÃ³fRWµ¼Ë„ÃÏ<Â ¤¸co–§q·˜Å	3–÷úøßÜ»CéXn3a4£g83ïÓÆ7XTÊŒê
CRV’n	ªê÷N‘.±_é.¦µ3;quûûî¾"ØÓ	¬>aõ`ÅĞÜî2X[Y,'\´±a ° ¥Î–©ì‘$DÒów-Í»§¬È"‡Ñ:CŸúÎ;74ær®_5¨–£ó\pm(ÎÍ8ôï0ˆ*ÏAPé,9œËÍáªSÒ1•[§çt7Ùû³ãRŸ˜Ïãdvİ’=b†Ft?zI…Q9FëÑlÅ=Yº÷ğ¤ó™@\½ÿî+-¢ÊÖàî71ÇuDD€À`„õU¤éş¥-Çoo\Ú5É«l/&²XÓYYƒ*²6¯Vú®4î•uÑÆ½ëäÓ-Ï|íLC™ĞÓlJFDæ:—M×4ï±šï™ß/_Û¼Î¥l*féÅÊ~tH_£æee]-ñıäa§ºW¢€âÙ÷—ôcq–]·üö;>p÷U‚¸êVE8_³¸V~¦#?¿¹.€À`Œ»S6¡•×üu­_áò¨#KdeGë°Îu©°â^ªJ$Ë3ôZ¹±ÛIügA\ÙD•®$èR^´m‰ÓÕµè•µùíA¤4¼39ßJÍÌ’J…¤q¶ÄÛ¦YXR h<O1sÔCÒÏ”Ç7|Å§SöËµç.\xíß~ê^Ö(ªa¢árÍâ^å5º»æÊ À(WyÜóæØéâ¼“óÛ–?ó”«´k¹Èje éÖuÂÜA¦é¯ba•–íîU|¡“O;®íÀ·dQÜ ²lV{¥+–Ößúøê	›z4ËQ&-wã¡’¦™–$éšáÅ*¦qÌ,Ä­Ş–ûÿı_/¹ì…§¢Õ‚jC¿2Ô¹fSÌ0wĞ5ûÊeV! X ŒÂ’¢ıÛ5??«şmG/İ»(sƒ¡Y-J}ç=]Qz»2ş†™Ü*“øÊgúÑï:7ú{cs²¼×Ê+àX©ÍïõÇ~ü+¿úaG­Ô¥j®i^7:U™ˆ2VÌiÿñ pŞ ¡'\V™§Ø¨Î(#¶HšC˜Şzó#›Ÿœ÷Şy—¬¿fy$®ú5«bil79WLéQduí¿‚X Œ²àQ[½…”ò`¸UÙÓ7,k÷ü
k¥globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (!matched)
                    continue;
                globParts[i] = matched;
                globParts[j] = [];
            }
        }
        return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = '';
        while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
                result.push(which === 'b' ? b[bi] : a[ai]);
                ai++;
                bi++;
            }
            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            }
            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            }
            else if (a[ai] === '*' &&
                b[bi] &&
                (this.options.dot || !b[bi].startsWith('.')) &&
                b[bi] !== '**') {
                if (which === 'b')
                    return false;
                which = 'a';
                result.push(a[ai]);
                ai++;
                bi++;
            }
            else if (b[bi] === '*' &&
                a[ai] &&
                (this.options.dot || !a[ai].startsWith('.')) &&
                a[ai] !== '**') {
                if (which === 'a')
                    return false;
                which = 'b';
                result.push(b[bi]);
                ai++;
                bi++;
            }
            else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length && result;
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive &&
                file[0] === '' &&
                file[1] === '' &&
                file[2] === '?' &&
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive &&
                pattern[0] === '' &&
                pattern[1] === '' &&
                pattern[2] === '?' &&
                typeof pattern[3] === 'string' &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === 'number' && typeof pdi === 'number') {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // dont' need to do the second phase, because it's only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug('matchOne', this, { file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' ||
                            file[fi] === '..' ||
                            (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swallowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
        assertValidPattern(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === 'object') {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, 'test', { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape(p)
                    : p === GLOBSTAR
                        ? GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== GLOBSTAR || prev === GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== GLOBSTAR) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
                }
                else if (next !== GLOBSTAR) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = GLOBSTAR;
                }
            });
            return pp.filter(p => p !== GLOBSTAR).join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return minimatch.defaults(def).Minimatch;
    }
}
/* c8 ignore start */
export { AST } from './ast.js';
export { escape } from './escape.js';
export { unescape } from './unescape.js';
/* c8 ignore stop */
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;
//# sourceMappingURL=index.js.map