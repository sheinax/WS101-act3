


import {IdentifierRole, isDeclaration, isObjectShorthandDeclaration} from "../parser/tokenizer";
import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";

import elideImportEquals from "../util/elideImportEquals";
import getDeclarationInfo, {

  EMPTY_DECLARATION_INFO,
} from "../util/getDeclarationInfo";
import getImportExportSpecifierInfo from "../util/getImportExportSpecifierInfo";
import isExportFrom from "../util/isExportFrom";
import {removeMaybeImportAttributes} from "../util/removeMaybeImportAttributes";
import shouldElideDefaultExport from "../util/shouldElideDefaultExport";


import Transformer from "./Transformer";

/**
 * Class for editing import statements when we are transforming to commonjs.
 */
export default class CJSImportTransformer extends Transformer {
   __init() {this.hadExport = false}
   __init2() {this.hadNamedExport = false}
   __init3() {this.hadDefaultExport = false}
  

  constructor(
     rootTransformer,
     tokens,
     importProcessor,
     nameManager,
     helperManager,
     reactHotLoaderTransformer,
     enableLegacyBabel5ModuleInterop,
     enableLegacyTypeScriptModuleInterop,
     isTypeScriptTransformEnabled,
     isFlowTransformEnabled,
     preserveDynamicImport,
     keepUnusedImports,
  ) {
    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.preserveDynamicImport = preserveDynamicImport;this.keepUnusedImports = keepUnusedImports;CJSImportTransformer.prototype.__init.call(this);CJSImportTransformer.prototype.__init2.call(this);CJSImportTransformer.prototype.__init3.call(this);;
    this.declarationInfo = isTypeScriptTransformEnabled
      ? getDeclarationInfo(tokens)
      : EMPTY_DECLARATION_INFO;
  }

  getPrefixCode() {
    let prefix = "";
    if (this.hadExport) {
      prefix += 'Object.defineProperty(exports, "__esModule", {value: true});';
    }
    return prefix;
  }

  getSuffixCode() {
    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {
      return "\nmodule.exports = exports.default;\n";
    }
    return "";
  }

  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {
      return this.processImportEquals();
    }
    if (this.tokens.matches1(tt._import)) {
      this.processImport();
      return true;
    }
    if (this.tokens.matches2(tt._export, tt.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (this.tokens.matches1(tt._export) && !this.tokens.currentToken().isType) {
      this.hadExport = true;
      return this.processExport();
    }
    if (this.tokens.matches2(tt.name, tt.postIncDec)) {
      // Fall through to normal identifier matching if this doesn't apply.
      if (this.processPostIncDec()) {
        return true;
      }
    }
    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.jsxName)) {
      return this.processIdentifier();
    }
    if (this.tokens.matches1(tt.eq)) {
      return this.processAssignment();
    }
    if (this.tokens.matches1(tt.assign)) {
      return this.processComplexAssignment();
    }
    if (this.tokens.matches1(tt.preIncDec)) {
      return this.processPreIncDec();
    }
    return false;
  }

   processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.importProcessor.shouldAutomaticallyElideImportedName(importName)) {
      // If this name is only used as a type, elide the whole import.
      elideImportEquals(this.tokens);
    } else {
      // Otherwise, switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

  /**
   * Transform this:
   * import foo, {bar} from 'baz';
   * into
   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
   *
   * The import code was already generated in the import preprocessing step, so
   * we just need to look it up.
   */
   processImport() {
    if (this.tokens.matches2(tt._import, tt.parenL)) {
      if (this.preserveDynamicImport) {
        // Bail out, only making progress for this one token.
        this.tokens.copyToken();
        return;
      }
      const requireWrapper = this.enableLegacyTypeScriptModuleInterop
        ? ""
        : `${this.helperManager.getHelperName("interopRequireWildcard")}(`;
      this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);
      const contextId = this.tokens.currentToken().contextId;
      if (contextId == null) {
        throw new Error("Expected context ID on dynamic import invocation.");
      }
      this.tokens.copyToken();
      while (!this.tokens.matchesContextIdAndLabel(tt.parenR, contextId)) {
        this.rootTransformer.processToken();
      }
      this.tokens.replaceToken(requireWrapper ? ")))" : "))");
      return;
    }

    const shouldElideImport = this.removeImportAndDetectIfShouldElide();
    if (shouldElideImport) {
      this.tokens.removeToken();
    } else {
      const path = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
      this.tokens.appendCode(this.importProcessor.claimImportCode(path));
    }
    removeMaybeImportAttributes(this.tokens);
    if (this.tokens.matches1(tt.semi)) {
      this.tokens.removeToken();
    }
  }

  /**
   * Erase this import (since any CJS output would be completely different), and
   * return true if this import is should be elided due to being a type-only
   * import. Such imports will not be emitted at all to avoid side effects.
   *
   * Import elision only happens with the TypeScript or Flow transforms enabled.
   *
   * TODO: This function has some awkward overlap with
   *  CJSImportProcessor.pruneTypeOnlyImports , and the two should be unified.
   *  That function handles TypeScript implicit import name elision, and removes
   *  an import if all typical imported names (without `type`) are removed due
   *  to being type-only imports. This function handles Flow import removal and
   *  properly distinguishes `import 'foo'` from `import {} from 'foo'` for TS
   *  purposes.
   *
   * The position should end at the import string.
   */
   removeImportAndDetectIfShouldElide() {
    this.tokens.removeInitialToken();
    if (
      this.tokens.matchesContextual(ContextualKeyword._type) &&
      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&
      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)
    ) {
      // This is an "import type" statement, so exit early.
      this.removeRemainingImport();
      return true;
    }

    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.star)) {
      // We have a default import or namespace import, so there must be some
      // non-type import.
      this.removeRemainingImport();
      return false;
    }

    if (this.tokens.matches1(tt.string)) {
      // This is a bare import, so we should proceed with the import.
      return false;
    }

    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    while (!this.tokens.matches1(tt.string)) {
      // Check if any named imports are of the form "foo" or "foo as bar", with
      // no leading "type".
      if (
        (!foundNonTypeImport && this.tokens.matches1(tt.braceL)) ||
        this.tokens.matches1(tt.comma)
      ) {
        this.tokens.removeToken();
        if (!this.tokens.matches1(tt.braceR)) {
          foundAnyNamedImport = true;
        }
        if (
          this.tokens.matches2(tt.name, tt.comma) ||
          this.tokens.matches2(tt.name, tt.braceR) ||
          this.tokens.matches4(tt.name, tt.name, tt.name, tt.comma) ||
          this.tokens.matches4(tt.name, tt.name, tt.name, tt.braceR)
        ) {
          foundNonTypeImport = true;
        }
      }
      this.tokens.removeToken();
    }
    if (this.keepUnusedImports) {
      return false;
    }
    if (this.isTypeScriptTransformEnabled) {
      return !foundNonTypeImport;
    } else if (this.isFlowTransformEnabled) {
      // In Flow, unlike TS, `import {} from 'foo';` preserves the import.
      return foundAnyNamedImport && !foundNonTypeImport;
    } else {
      return false;
    }
  }

   removeRemainingImport() {
    while (!this.tokens.matches1(tt.string)) {
      this.tokens.removeToken();
    }
  }

   processIdentifier() {
    const token = this.tokens.currentToken();
    if (token.shadowsGlobal) {
      return false;
    }

    if (token.identifierRole === IdentifierRole.ObjectShorthand) {
      return this.processObjectShorthand();
    }

    if (token.identifierRole !== IdentifierRole.Access) {
      return false;
    }
    const replacement = this.importProcessor.getIdentifierReplacement(
      this.tokens.identifierNameForToken(token),
    );
    if (!replacement) {
      return false;
    }
    // Tolerate any number of closing parens while looking for an opening paren
    // that indicates a function call.
    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;
    while (
      possibleOpenParenIndex < this.tokens.tokens.length &&
      this.tokens.tokens[possibleOpenParenIndex].type === tt.parenR
    ) {
      possibleOpenParenIndex++;
    }
    // Avoid treating imported functions as methods of their `exports` object
    // by using `(0, f)` when the identifier is in a paren expression. Else
    // use `Function.prototype.call` when the identifier is a guaranteed
    // function call. When using `call`, pass undefined as the context.
    if (this.tokens.tokens[possibleOpenParenIndex].type === tt.parenL) {
      if (
        this.tokens.tokenAtRelativeIndex(1).type === tt.parenL &&
        this.tokens.tokenAtRelativeIndex(-1).type !== tt._new
      ) {
        this.tokens.replaceToken(`${replacement}.call(void 0, `);
        // Remove the old paren.
        this.tokens.removeToken();
        // Balance out the new paren.
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(tt.parenR);
      } else {
        // See here: http://2ality.com/2015/12/references.html
        this.tokens.replaceToken(`(0, ${replacement})`);
      }
    } else {
      this.tokens.replaceToken(replacement);
    }
    return true;
  }

  processObjectShorthand() {
    const identifier = this.tokens.identifierName();
    const replacement = this.importProcessor.getIdentifierReplacement(identifier);
    if (!replacement) {
      return false;
    }
    this.tokens.replaceToken(`${identifier}: ${replacement}`);
    return true;
  }

  processExport() {
    if (
      this.tokens.matches2(tt._export, tt._enum) ||
      this.tokens.matches3(tt._export, tt._const, tt._enum)
    ) {
      this.hadNamedExport = true;
      // Let the TypeScript transform handle it.
      return false;
    }
    if (this.tokens.matches2(tt._export, tt._default)) {
      if (this.tokens.matches3(tt._export, tt._default, tt._enum)) {
        this.hadDefaultExport = true;
        // Flow export default enums need some special handling, so handle them
        // in that tranform rather than this one.
        return false;
      }
      this.processExportDefault();
      return true;
    } else if (this.tokens.matches2(tt._export, tt.braceL)) {
      this.processExportBindings();
      return true;
    } else if (
      this.tokens.matches2(tt._export, tt.name) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // export type {a};
      // export type {a as b};
      // export type {a} from './b';
      // export type * from './b';
      // export type * as ns from './b';
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(tt.braceL)) {
        while (!this.tokens.matches1(tt.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        // *
        this.tokens.removeToken();
        if (this.tokens.matches1(tt._as)) {
          // as
          this.tokens.removeToken();
          // ns
          this.tokens.removeToken();
        }
      }
      // Remove type re-export `... } from './T'`
      if (
        this.tokens.matchesContextual(ContextualKeyword._from) &&
        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)
      ) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        removeMaybeImportAttributes(this.tokens);
      }
      return true;
    }
    this.hadNamedExport = true;
    if (
      this.tokens.matches2(tt._export, tt._var) ||
      this.tokens.matches2(tt._export, tt._let) ||
      this.tokens.matches2(tt._export, tt._const)
    ) {
      this.processExportVar();
      return true;
    } else if (
      this.tokens.matches2(tt._export, tt._function) ||
      // export async function
      this.tokens.matches3(tt._export, tt.name, tt._function)
    ) {
      this.processExportFunction();
      return true;
    } else if (
      this.tokens.matches2(tt._export, tt._class) ||
      this.tokens.matches3(tt._export, tt._abstract, tt._class) ||
      this.tokens.matches2(tt._export, tt.at)
    ) {
      this.processExportClass();
      return true;
    } else if (this.tokens.matches2(tt._export, tt.star)) {
      this.processExportStar();
      return true;
    } else {
      throw new Error("Unrecognized export syntax.");
    }
  }

   processAssignment() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index - 1];
    // If the LHS is a type identifier, this must be a declaration like `let a: b = c;`,
    // with `b` as the identifier, so nothing needs to be done in that case.
    if (identifierToken.isType || identifierToken.type !== tt.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {
      return false;
    }
    if (index >= 2 && [tt._var, tt._let, tt._const].includes(this.tokens.tokens[index - 2].type)) {
      // Declarations don't need an extra assignment. This doesn't avoid the
      // assignment for comma-separated declarations, but it's still correct
      // since the assignment is just redundant.
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(identifierToken),
    );
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.copyToken();
    this.tokens.appendCode(` ${assignmentSnippet} =`);
    return true;
  }

  /**
   * Process something like `a += 3`, where `a` might be an exported value.
   */
   processComplexAssignment() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index - 1];
    if (identifierToken.type !== tt.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(identifierToken),
    );
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(` = ${assignmentSnippet}`);
    this.tokens.copyToken();
    return true;
  }

  /**
   * Process something like `++a`, where `a` might be an exported value.
   */
   processPreIncDec() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index + 1];
    if (identifierToken.type !== tt.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    // Ignore things like ++a.b and ++a[b] and ++a().b.
    if (
      index + 2 < this.tokens.tokens.length &&
      (this.tokens.matches1AtIndex(index + 2, tt.dot) ||
        this.tokens.matches1AtIndex(index + 2, tt.bracketL) ||
        this.tokens.matches1AtIndex(index + 2, tt.parenL))
    ) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(`${assignmentSnippet} = `);
    this.tokens.copyToken();
    return true;
  }

  /**
   * Process something like `a++`, where `a` might be an exported value.
   * This starts at the `a`, not at the `++`.
   */
   processPostIncDec() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index];
    const operatorToken = this.tokens.tokens[index + 1];
    if (identifierToken.type !== tt.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, tt.dot)) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    const operatorCode = this.tokens.rawCodeForToken(operatorToken);
    // We might also replace the identifier with something like exports.x, so
    // do that replacement here as well.
    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;
    if (operatorCode === "++") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);
    } else if (operatorCode === "--") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);
    } else {
      throw new Error(`Unexpected operator: ${operatorCode}`);
    }
    this.tokens.removeToken();
    return true;
  }

   processExportDefault() {
    let exportedRuntimeValue = true;
    if (
      this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||
      // export default async function
      (this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) &&
        this.tokens.matchesContextualAtIndex(
          this.tokens.currentIndex() + 2,
          ContextualKeyword._async,
        ))
    ) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      // Named function export case: change it to a top-level function
      // declaration followed by exports statement.
      const name = this.processNamedFunction();
      this.tokens.appendCode(` exports.default = ${name};`);
    } else if (
      this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) ||
      this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name) ||
      this.tokens.matches3(tt._export, tt._default, tt.at)
    ) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.copyDecorators();
      if (this.tokens.matches1(tt._abstract)) {
        this.tokens.removeToken();
      }
      const name = this.rootTransformer.processNamedClass();
      this.tokens.appendCode(` exports.default = ${name};`);
      // After this point, this is a plain "export default E" statement.
    } else if (
      shouldElideDefaultExport(
        this.isTypeScriptTransformEnabled,
        this.keepUnusedImports,
        this.tokens,
        this.declarationInfo,
      )
    ) {
      // If the exported value is just an identifier and should be elided by TypeScript
      // rules, then remove it entirely. It will always have the form `export default e`,
      // where `e` is an identifier.
      exportedRuntimeValue = false;
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.tokens.removeToken();
    } else if (this.reactHotLoaderTransformer) {
      // We need to assign E to a variable. Change "export default E" to
      // "let _default; exporH‹YL‰D$0L‰AH…Ût9ƒÈÿğÁCƒøu,H‹H‹ËH‹ ÿÚb ƒÈÿğÁCƒøuH‹H‹ËH‹@ÿ½b H‹\$8H‹ÇHƒÄ _ÃÌÌÌÌÌÌÌH‹ÄAVHƒì0HÇ@èşÿÿÿH‰XH‰pH‰xH‹òH‹ÙHyLrI;şt%H‹Ïè¤1  L‹I‹H‰M‰H‹OI‹FH‰GI‰NH{LvI;şt%H‹Ïè23  H‹I‹H‰I‰H‹OI‹FH‰GI‰NH‹F(H‰C(H‹ÃH‹\$@H‹t$HH‹|$PHƒÄ0A^ÃÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$ WHƒì HjH‹úHqH‹ÙH;õtH‹Îèı0  DŠD$0H‹ÕH‹ÎèÎÿÿHoHsH;õtH‹Îè˜2  DŠD$0H‹ÕH‹ÎèXĞÿÿH‹G(H‹l$@H‹t$HH‰C(H‹ÃH‹\$8HƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌÌH‹ÁóÃÌÌÌÌÌ@WHƒì0HÇD$ şÿÿÿH‰\$@H‰t$HH‹úH‹ÙH;Êt"èÏ™ôÿL‹H‹H‰L‰H‹KH‹GH‰CH‰OHsHƒÇH;÷t%H‹Îè]õÿH‹H‹H‰H‰H‹NH‹GH‰FH‰OH‹ÃH‹\$@H‹t$HHƒÄ0_ÃÌÌÌÌÌH‰\$H‰t$WHƒì H‹úH‹ÙH;ÊtèI™ôÿDŠD$0H‹×H‹ËèÁÎÿÿHwH{H;ştH‹Ïèä
õÿDŠD$0H‹ÖH‹Ïè ÎÿÿH‹t$@H‹ÃH‹\$8HƒÄ _ÃÌÌÌÌÌÌÌÌÌH‰\$WHƒì ŠH‹ÚˆH‹ùŠBHƒÂˆAHƒÁèıëñÿHS(HO(èğëñÿHSHHOHèãëñÿ‹Ch‰Gh‹Cl‰Gl‹Cp‰Gp‹Ct‰Gt‹Cx‰Gx‹C|‰G|‹ƒ€   ‰‡€   ‹ƒ„   H‹\$0‰‡„   H‹ÇHƒÄ _ÃÌÌÌÌÌH‰\$WHƒì ŠH‹ÚˆH‹ùŠBHƒÂˆAHƒÁèeöóÿHS(HO(èXöóÿHSHHOHèKöóÿ‹Ch‰Gh‹Cl‰Gl‹Cp‰Gp‹Ct‰Gt‹Cx‰Gx‹C|‰G|‹ƒ€   ‰‡€   ‹ƒ„   H‹\$0‰‡„   H‹ÇHƒÄ _ÃÌÌÌÌÌH‹H‰H‹ÁÃÌÌH‹ÄUVWHh¡Hìğ   HÇE‡şÿÿÿH‰XH‹Ğü! H3ÄH‰E7H‹òH‹ùƒyXuwfo51 óE'ÆE HMè³”ôÿHO0LEHT$ èîÿÿH‹|$ H‹U/Hƒúr2HÿÂH‹MH‹Á»   H;ÓrHƒÂ'H‹IøH+ÁHƒÀøHƒø‡X  è;ûÿHG@é  ƒyX …  ÇAX   HE—H‰Efo¥0 óEÆE÷ HM÷è#”ôÿHM—èÙßóÿH‹ØH‰D$ LE÷HUHO0èhíÿÿH‹MHƒÁ@H‹Óè`”ôÿH‹Ëèóóÿ»   H‹UHƒúr-HÿÂH‹M÷H‹ÁH;ÓrHƒÂ'H‹IøH+ÁHƒÀøHƒø‡—   è†ûÿfo0 óEÆE÷ H‹ÖHM÷è“ôÿLE÷HUHO0èãìÿÿH‹}H‹UHƒú‚
ÿÿÿHÿÂH‹M÷H‹ÁH;Ó‚òşÿÿHƒÂ'H‹IøH+ÁHƒÀøHƒøw/éØşÿÿèû  H‹M7H3Ìè‹
ûÿH‹œ$   HÄğ   _^]ÃèKYüÿÌèEYüÿÌè?YüÿÌÌÌÌÌÌÌ@WHƒì0HÇD$ şÿÿÿH‰\$@H‰t$H‹òH‹ùöÂt8HYøL‚wğÿL‹º   è
ûÿ@öÆtH‹HÕ   H‹Ëè³ûÿH‹Ãë@öÆtº   èqûÿH‹ÇH‹\$@H‹t$HHƒÄ0_ÃÌ@WHƒì0HÇD$ şÿÿÿH‰\$@H‰t$H‹òH‹ÙöÂt<HyøLÒìóÿL‹º0   è
ûÿ@öÆtH‹HIHÁâHƒÂH‹Ïè/ûÿH‹Çëèœìóÿ@öÆtº0   H‹ËèäûÿH‹ÃH‹\$@H‹t$HHƒÄ0_ÃÌÌÌÌ@WHƒì0HÇD$ şÿÿÿH‰\$@H‰t$H‹òH‹ÙöÂt8HyøL2öÿÿL‹º   èq	ûÿ@öÆtH‹HÕ   H‹Ïè£ûÿH‹ÇëH®  H‰@öÆtº   èWûÿH‹ÃH‹\$@H‹t$HHƒÄ0_ÃÌÌÌ@WHƒì0HÇD$ şÿÿÿH‰\$@H‰t$H‹òH‹ÙöÂt<HyøL¶õÿÿL‹º   èåûÿ@öÆtH‹HIHÕ   H‹ÏèûÿH‹Çë4HÎ  H‰H$¢ H‰AH1¢ H‰A@öÆtº   è±ûÿH‹ÃH‹\$@H‹t$HHƒÄ0_ÃÌHƒééSÿÿÿÌÌÌÌÌÌÌ@WHƒì0HÇD$ şÿÿÿH‰\$@H‰t$H‹òH‹ÙöÂt8HyøL2õÿÿL‹º   è1ûÿ@öÆtH‹HÕ   H‹ÏècûÿH‹ÇëH H‰@öÆtº   èûÿH‹ÃH‹\$@H‹t$HHƒÄ0_ÃÌÌÌÌÌÌÌ@WHƒì0HÇD$ şÿÿÿH‰\$@H‰t$H‹òH‹ÙöÂt8HyøL²ôÿÿL‹º   è¡ûÿ@öÆtH‹HÕ   H‹ÏèÓûÿH‹ÇëHfš H‰@öÆtº   è‡
ûÿH‹ÃH‹\$@H‹t$HHƒÄ0_ÃÌÌÌÌÌÌÌ@SHƒì H‹ÙöÂt
ºx   èT
ûÿH‹ÃHƒÄ [ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì H‹ÙöÂt
º0   è$
ûÿH‹ÃHƒÄ [ÃÌÌÌHƒì8HÇD$ şÿÿÿ‹Ñ”# eH‹%X   A¸0  H‹ÈA‹9¬©# HC©# HƒÄ8ÃH—©# èJûÿƒ=‹©# ÿußH"©# èÚóÿH: è•	ûÿHi©# è¼ûÿë¸ÌÌéû›  ÌÌÌÌÌÌÌÌÌÌÌé+œ  ÌÌÌÌÌÌÌÌÌÌÌH‹ÄH‰XH‰hH‰pH‰x ATAVAWHƒì DŠâH‹ùH© I‹ÈM‹ùI‹ğèX”  L5Ü H…ÿI‹ÖH‹èHE×HXÇ@X   H‹ËèAôÿHƒ{rH‹HˆŸ H‰]H‹Îè”  H‹L$`HP§ E„äH H‰HHEßH‹ÎÇ@X   èç“  H‹ÈHé‰ èäøÿÿH…ÛH‹èLEóHxÇ@X   I‹ÖH‹ÏèÈôÿHƒrH‹?I‹×H‰}H‹ÎH‹\$@H‹l$HH‹t$PH‹|$XHƒÄ A_A^A\éÑš  Ìéû›  ÌÌÌÌÌÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹Wõ! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èº  fo³) óD$`ÆD$P HÙ˜ HL$Pè'ôÿH‹LD$(HT$PH‹ËH‹€è   ÿ1W H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è«ûÿfo7) óD$`ÆD$P HL$(è2À  H‹L$pH3ÌèûÿHÄ€   [ÃèÏRüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹gô! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(è¹  foÃ( óD$`ÆD$P HA˜ HL$Pè7ŒôÿH‹LD$(HT$PH‹ËH‹€è   ÿAV H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøwHè»ûÿfoG( óD$`ÆD$P HL$(èB¿  H‹H‹ËH‹@PÿÚU H‹L$pH3ÌèûÿHÄ€   [ÃèÏQüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹gó! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(è¸  foÃ' óD$`ÆD$P H)— HL$Pè7‹ôÿH‹LD$(HT$PH‹ËH‹€è   ÿAU H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è»ûÿfoG' óD$`ÆD$P HL$(èB¾  H‹L$pH3ÌèûÿHÄ€   [ÃèßPüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹wò! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(è,·  foÓ& óD$`ÆD$P Ha– HL$PèGŠôÿH‹LD$(HT$PH‹ËH‹€è   ÿQT H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8èËûÿfoW& óD$`ÆD$P HL$(èR½  H‹L$pH3Ìè%ûÿHÄ€   [ÃèïOüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹‡ñ! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(è<¶  foã% óD$`ÆD$P H• HL$PèW‰ôÿH‹LD$(HT$PH‹ËH‹€è   ÿaS H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8èÛûÿfog% óD$`ÆD$P HL$(èb¼  H‹L$pH3Ìè5 ûÿHÄ€   [ÃèÿNüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹—ğ! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èLµ  foó$ óD$`ÆD$P HÑÀ HL$PègˆôÿH‹LD$(HT$PH‹ËH‹€è   ÿqR H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8èëûÿfow$ óD$`ÆD$P HL$(èr»  H‹L$pH3ÌèEÿúÿHÄ€   [ÃèNüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹§ï! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(è\´  fo$ óD$`ÆD$P HI“ HL$Pèw‡ôÿH‹LD$(HT$PH‹ËH‹€è   ÿQ H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8èûûÿfo‡# óD$`ÆD$P HL$(è‚º  H‹L$pH3ÌèUşúÿHÄ€   [ÃèMüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹·î! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èl³  fo# óD$`ÆD$P Hi’ HL$Pè‡†ôÿH‹LD$(HT$PH‹ËH‹€è   ÿ‘P H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8èûÿfo—" óD$`ÆD$P HL$(è’¹  H‹L$pH3ÌèeıúÿHÄ€   [Ãè/LüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹Çí! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(è|²  fo#" óD$`ÆD$P HA“ HL$Pè—…ôÿH‹LD$(HT$PH‹ËH‹€è   ÿ¡O H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è ûÿfo§! óD$`ÆD$P HL$(è¢¸  H‹L$pH3ÌèuüúÿHÄ€   [Ãè?KüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹×ì! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èŒ±  fo3! óD$`ÆD$P H‘ HL$Pè§„ôÿH‹LD$(HT$PH‹ËH‹€è   ÿ±N H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è+ÿúÿfo·  óD$`ÆD$P HL$(è²·  H‹L$pH3Ìè…ûúÿHÄ€   [ÃèOJüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹çë! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èœ°  foC  óD$`ÆD$P Hé HL$Pè·ƒôÿH‹LD$(HT$PH‹ËH‹€è   ÿÁM H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è;şúÿfoÇ óD$`ÆD$P HL$(èÂ¶  H‹L$pH3Ìè•úúÿHÄ€   [Ãè_IüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹÷ê! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(è¬¯  foS óD$`ÆD$P H	 HL$PèÇ‚ôÿH‹LD$(HT$PH‹ËH‹€è   ÿÑL H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8èKıúÿfo× óD$`ÆD$P HL$(èÒµ  H‹L$pH3Ìè¥ùúÿHÄ€   [ÃèoHüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹ê! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(è¼®  foc óD$`ÆD$P H) HL$Pè×ôÿH‹LD$(HT$PH‹ËH‹€è   ÿáK H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è[üúÿfoç óD$`ÆD$P HL$(èâ´  H‹L$pH3ÌèµøúÿHÄ€   [ÃèGüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹é! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èÌ­  fos óD$`ÆD$P Hi HL$Pèç€ôÿH‹LD$(HT$PH‹ËH‹€è   ÿñJ H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8èkûúÿfo÷ óD$`ÆD$P HL$(èò³  H‹L$pH3ÌèÅ÷úÿHÄ€   [ÃèFüÿÌÌÌÌÌÌL‹ÜWHƒì`IÇCÈşÿÿÿI‰[H‹%è! H3ÄH‰D$X¶ÚH‹ùfo óD$HÆD$8 HŠ IKĞè€ôÿD‹Ãƒd$  E3ÉHT$8H‹Ïè«j  H‹T$PHƒúr.HÿÂH‹L$8H‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw èúúÿH‹L$XH3Ìè÷úÿH‹œ$€   HƒÄ`_ÃèÉEüÿÌ@SHì€   HÇD$ şÿÿÿH‹gç! H3ÄH‰D$pH‹Ù…Òt3ƒêt%ƒêtƒút	HÍı ë"Hñ‹ ëHà‹ ëHÇ‹ ëH¦· E3ÉE3ÀHL$(è®­  fo… óD$`ÆD$P H»‹ HL$Pèù~ôÿH‹LD$(HT$PH‹ËH‹€è   ÿI H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è}ùúÿfo	 óD$`ÆD$P HL$(è²  H‹L$pH3Ìè×õúÿHÄ€   [Ãè¡DüÿÌÌÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹7æ! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èìª  fo“ óD$`ÆD$P HáŠ HL$Pè~ôÿH‹LD$(HT$PH‹ËH‹€è   ÿH H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è‹øúÿfo óD$`ÆD$P HL$(è±  H‹L$pH3ÌèåôúÿHÄ€   [Ãè¯CüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹Gå! H3ÄH‰D$pH‹Ù…Òt3ƒêt%ƒêtƒút	H­û ë"H%Š ëHŠ ëHŠ ëH†µ E3ÉE3ÀHL$(è«  foe óD$`ÆD$P Hë‰ HL$PèÙ|ôÿH‹LD$(HT$PH‹ËH‹€è   ÿãF H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è]÷úÿfoé óD$`ÆD$P HL$(èä¯  H‹L$pH3Ìè·óúÿHÄ€   [ÃèBüÿÌÌÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹ä! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èÌ¨  fos óD$`ÆD$P H‰´ HL$Pèç{ôÿH‹LD$(HT$PH‹ËH‹€è   ÿñE H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8èköúÿfo÷ óD$`ÆD$P HL$(èò®  H‹L$pH3ÌèÅòúÿHÄ€   [ÃèAüÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹'ã! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èÜ§  foƒ óD$`ÆD$P H!ˆ HL$Pè÷zôÿH‹LD$(HT$PH‹ËH‹€è   ÿE H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è{õúÿfo óD$`ÆD$P HL$(è®  H‹L$pH3ÌèÕñúÿHÄ€   [ÃèŸ@üÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹7â! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èì¦  fo“ óD$`ÆD$P H‘² HL$PèzôÿH‹LD$(HT$PH‹ËH‹€è   ÿD H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è‹ôúÿfo óD$`ÆD$P HL$(è­  H‹L$pH3ÌèåğúÿHÄ€   [Ãè¯?üÿÌÌÌÌÌÌM¾Àé'd  ÌÌÌÌÌÌÌE¶Àéd  ÌÌÌÌÌÌÌM¿Àéd  ÌÌÌÌÌÌÌE·Àé÷c  ÌÌÌÌÌÌÌMcÀéèc  ÌÌÌÌÌÌÌÌE‹ÀéØc  ÌÌÌÌÌÌÌÌéËc  ÌÌÌÌÌÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹×à! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èŒ¥  fo3 óD$`ÆD$P Ha± HL$Pè§xôÿH‹LD$(HT$PH‹ËH‹€è   ÿ±B H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è+óúÿfo· óD$`ÆD$P HL$(è²«  H‹L$pH3Ìè…ïúÿHÄ€   [ÃèO>üÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹çß! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èœ¤  foC óD$`ÆD$P H… HL$Pè·wôÿH‹LD$(HT$PH‹ËH‹€è   ÿÁA H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è;òúÿfoÇ óD$`ÆD$P HL$(èÂª  H‹L$pH3Ìè•îúÿHÄ€   [Ãè_=üÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹÷Ş! H3ÄH‰D$pH‹ÙE3ÉHL$(è¯£  foV óD$`ÆD$P H„ HL$PèÊvôÿH‹LD$(HT$PH‹ËH‹€è   ÿÔ@ H‹T$hHƒúr/HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw&èNñúÿHL$(èç©  H‹L$pH3ÌèºíúÿHÄ€   [Ãè„<üÿÌÌÌÌÌÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹Ş! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èÌ¢  fos óD$`ÆD$P Haƒ HL$PèçuôÿH‹LD$(HT$PH‹ËH‹€è   ÿñ? H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8èkğúÿfo÷ óD$`ÆD$P HL$(èò¨  H‹L$pH3ÌèÅìúÿHÄ€   [Ãè;üÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹'İ! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èÜ¡  foƒ óD$`ÆD$P HI‚ HL$Pè÷tôÿH‹LD$(HT$PH‹ËH‹€è   ÿ? H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è{ïúÿfo óD$`ÆD$P HL$(è¨  H‹L$pH3ÌèÕëúÿHÄ€   [ÃèŸ:üÿÌÌÌÌÌÌ@SHì€   HÇD$ şÿÿÿH‹7Ü! H3ÄH‰D$pH‹ÙE3ÉE3ÀHL$(èì   fo“ óD$`ÆD$P H™ HL$PètôÿH‹LD$(HT$PH‹ËH‹€è   ÿ> H‹T$hHƒúr.HÿÂH‹L$PH‹ÁHú   rHƒÂ'H‹IøH+ÁHƒÀøHƒøw8è‹îúÿfo óD$`ÆD$P HL$(è§  H‹L$pH3ÌèåêúÿHÄ€   [Ãè¯9üÿÌÌH‰L$Hƒì8HÇD$ şÿÿÿ¹@   èØêúÿH‰D$HH‰ H‰@H‰@fÇ@HƒÄ8ÃÌH‰L$Hƒì8HÇD$ şÿÿÿ¹h   è êúÿH‰D$HH‰ H‰@H‰@fÇ@HƒÄ8ÃÌH‰L$Hƒì8HÇD$ şÿÿÿ¹P   èhêúÿH‰D$HH‰ H‰@H‰@fÇ@HƒÄ8ÃÌH‰L$Hƒì8HÇD$ şÿÿÿ¹    è0êúÿH‰D$HH‰ H‰@H‰@fÇ@HƒÄ8ÃÌH‰L$Hƒì8HÇD$ şÿÿÿ¹   èøéúÿH‰D$HH‰ H‰@H‰@fÇ@HƒÄ8ÃÌH‰L$Hƒì8HÇD$ şÿÿÿ¹(   èÀéúÿH‰D$HH‰ H‰@H‰@fÇ@HƒÄ8ÃÌH‰L$SHƒì0HÇD$ şÿÿÿH‹Ù¹@   è„éúÿH‰D$HH‹H‰H‹H‰PH‹H‰HHƒÄ0[ÃÌH‰L$SHƒì0HÇD$ şÿÿÿH‹Ù¹h   èDéúÿH‰D$HH‹H‰H‹H‰PH‹H‰HHƒÄ0[ÃÌH‰L$SHƒì0HÇD$ şÿÿÿH‹Ù¹P   èéúÿH‰D$HH‹H‰H‹H‰PH‹H‰HHƒÄ0[ÃÌH‰L$SHƒì0HÇD$ şÿÿÿH‹Ù¹    èÄèúÿH‰D$HH‹H‰H‹H‰PH‹H‰HHƒÄ0[ÃÌH‰L$SHƒì0HÇD$ şÿÿÿH‹Ù¹   è„èúÿH‰D$HH‹H‰H‹H‰PH‹H‰HHƒÄ0[ÃÌH‰L$SHƒì0HÇD$ şÿÿÿH‹Ù¹(   èDèúÿH‰D$HH‹H‰H‹H‰PH‹H‰HHƒÄ0[ÃÌH‰\$H‰l$H‰t$WHƒì H‹rA¸   H‹ÚH‹ùL9BrH‹I;ğsH‹ÓèúûÿHÇG   ëtH¸ÿÿÿÿÿÿÿH‹îHƒÍH;èHGèHUHú   r*HJ'HƒÈÿH;ÊHFÈè§çúÿH‹ÈH…ÀtLH@'HƒààH‰Høë3ÀH…ÒtH‹Êè‚çúÿLFH‰H‹ÓH‹Èè€ûÿH‰oH‹\$0H‹l$8H‰wH‹t$@HƒÄ _Ãè6üÿÌÌ@SHƒì HJ H‹ÚèVÓÿÿºh   H‹ËHƒÄ [é„êúÿ@SHƒì HJ H‹Úè–Åóÿº    H‹ËHƒÄ [é`êúÿ@SHƒì HJ(H‹Úè:Õÿÿº   H‹ËHƒÄ [é<êúÿH‰\$H‰t$WHƒì €z H‹ÚH‹ñH‹úu0H‹WH‹ÎèÖÿÿÿH‹?HK 3ÒèàŞóÿº@   H‹Ëè÷éúÿ€ H‹ßtĞH‹\$0H‹t$8HƒÄ _ÃÌÌH‰\$H‰t$WHƒì €z H‹ÚH‹ñH‹úu.H‹WH‹ÎèÖÿÿÿH‹?HK èfÒÿÿºh   H‹Ëè™éúÿ€ H‹ßtÒH‹\$0H‹t$8HƒÄ _ÃH‰\$H‰t$WHƒì €z H‹ÚH‹ñH‹úu.H‹WH‹ÎèÖÿÿÿH‹?HK èÃóÿºP   H‹Ëè=éúÿ€ H‹ßtÒH‹\$0H‹t$8HƒÄ _ÃH‰\$H‰t$WHƒì €z H‹ÚH‹ñH‹úu.H‹WH‹ÎèÖÿÿÿH‹?HK èÄóÿº    H‹Ëèáèúÿ€ H‹ßtÒH‹\$0H‹t$8