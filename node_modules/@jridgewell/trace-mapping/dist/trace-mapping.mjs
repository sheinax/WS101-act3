import { encode, decode } from '@jridgewell/sourcemap-codec';
import resolveUri from '@jridgewell/resolve-uri';

function resolve(input, base) {
    // The base is always treated as a directory, if it's not empty.
    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327
    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401
    if (base && !base.endsWith('/'))
        base += '/';
    return resolveUri(input, base);
}

/**
 * Removes everything after the last "/", but leaves the slash.
 */
function stripFilename(path) {
    if (!path)
        return '';
    const index = path.lastIndexOf('/');
    return path.slice(0, index + 1);
}

const COLUMN = 0;
const SOURCES_INDEX = 1;
const SOURCE_LINE = 2;
const SOURCE_COLUMN = 3;
const NAMES_INDEX = 4;
const REV_GENERATED_LINE = 1;
const REV_GENERATED_COLUMN = 2;

function maybeSort(mappings, owned) {
    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
    if (unsortedIndex === mappings.length)
        return mappings;
    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If
    // not, we do not want to modify the consumer's input array.
    if (!owned)
        mappings = mappings.slice();
    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
        mappings[i] = sortSegments(mappings[i], owned);
    }
    return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
    for (let i = start; i < mappings.length; i++) {
        if (!isSorted(mappings[i]))
            return i;
    }
    return mappings.length;
}
function isSorted(line) {
    for (let j = 1; j < line.length; j++) {
        if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
        }
    }
    return true;
}
function sortSegments(line, owned) {
    if (!owned)
        line = line.slice();
    return line.sort(sortComparator);
}
function sortComparator(a, b) {
    return a[COLUMN] - b[COLUMN];
}

let found = false;
/**
 * A binary search implementation that returns the index if a match is found.
 * If no match is found, then the left-index (the index associated with the item that comes just
 * before the desired index) is returned. To maintain proper sort order, a splice would happen at
 * the next index:
 *
 * ```js
 * const array = [1, 3];
 * const needle = 2;
 * const index = binarySearch(array, needle, (item, needle) => item - needle);
 *
 * assert.equal(index, 0);
 * array.splice(index + 1, 0, needle);
 * assert.deepEqual(array, [1, 2, 3]);
 * ```
 */
function binarySearch(haystack, needle, low, high) {
    while (low <= high) {
        const mid = low + ((high - low) >> 1);
        const cmp = haystack[mid][COLUMN] - needle;
        if (cmp === 0) {
            found = true;
            return mid;
        }
        if (cmp < 0) {
            low = mid + 1;
        }
        else {
            high = mid - 1;
        }
    }
    found = false;
    return low - 1;
}
function upperBound(haystack, needle, index) {
    for (let i = index + 1; i < haystack.length; index = i++) {
        if (haystack[i][COLUMN] !== needle)
            break;
    }
    return index;
}
function lowerBound(haystack, needle, index) {
    for (let i = index - 1; i >= 0; index = i--) {
        if (haystack[i][COLUMN] !== needle)
            break;
    }
    return index;
}
function memoizedState() {
    return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1,
    };
}
/**
 * This overly complicated beast is just to record the last tested line/column and the resulting
 * index, allowing us to skip a few tests if mappings are monotonically increasing.
 */
function memoizedBinarySearch(haystack, needle, state, key) {
    const { lastKey, lastNeedle, lastIndex } = state;
    let low = 0;
    let high = haystack.length - 1;
    if (key === lastKey) {
        if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
        }
        if (needle >= lastNeedle) {
            // lastIndex may be -1 if the previous needle was not found.
            low = lastIndex === -1 ? 0 : lastIndex;
        }
        else {
            high = lastIndex;
        }
    }
    state.lastKey = key;
    state.lastNeedle = needle;
    return (state.lastIndex = binarySearch(haystack, needle, low, high));
}

// Rebuilds the original source files, with mappings that are ordered by source line/column instead
// of generated line/column.
function buildBySources(decoded, memos) {
    const sources = memos.map(buildNullArray);
    for (let i = 0; i < decoded.length; i++) {
        const line = decoded[i];
        for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1)
                continue;
            const sourceIndex = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex];
            const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));
            const memo = memos[sourceIndex];
            // The binary search either found a match, or it found the left-index just before where the
            // segment should go. Either way, we want to insert after that. And there may be multiple
            // generated segments associated with an original location, so there may need to move several
            // indexes before we find where we need to insert.
            let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            memo.lastIndex = ++index;
            insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);
        }
    }
    return sources;
}
function insert(array, index, value) {
    for (let i = array.length; i > index; i--) {
        array[i] = array[i - 1];
    }
    array[index] = value;
}
// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like
// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.
// Numeric properties on objects are magically sorted in ascending order by the engine regardless of
// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending
// order when iterating with for-in.
function buildNullArray() {
    return { __proto__: null };
}

const AnyMap = function (map, mapUrl) {
    const parsed = parse(map);
    if (!('sections' in parsed)) {
        return new TraceMap(parsed, mapUrl);
    }
    const mappings = [];
    const sources = [];
    const sourcesContent = [];
    const names = [];
    const ignoreList = [];
    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
    const joined = {
        version: 3,
        file: parsed.file,
        names,
        sources,
        sourcesContent,
        mappings,
        ignoreList,
    };
    return presortedDecodedMap(joined);
};
function parse(map) {
    return typeof map === 'string' ? JSON.parse(map) : map;
}
function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
    const { sections } = input;
    for (let i = 0; i < sections.length; i++) {
        const { map, offset } = sections[i];
        let sl = stopLine;
        let sc = stopColumn;
        if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
                sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            }
            else if (sl < stopLine) {
                sc = columnOffset + nextOffset.column;
            }
        }
        addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
    }
}
function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
    const parsed = parse(input);
    if ('sections' in parsed)
        return recurse(...arguments);
    const map = new TraceMap(parsed, mapUrl);
    const sourcesOffset = sources.length;
    const namesOffset = names.length;
    const decoded = decodedMappings(map);
    const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
    append(sources, resolvedSources);
    append(names, map.names);
    if (contents)
        append(sourcesContent, contents);
    else
        for (let i = 0; i < resolvedSources.length; i++)
            sourcesContent.push(null);
    if (ignores)
        for (let i = 0; i < ignores.length; i++)
            ignoreList.push(ignores[i] + sourcesOffset);
    for (let i = 0; i < decoded.length; i++) {
        const lineI = lineOffset + i;
        // We can only add so many lines before we step into the range that the next section's map
        // controls. When we get to the last line, then we'll start checking the segments to see if
        // they've crossed into the column range. But it may not have any columns that overstep, so we
        // still need to check that we don't overstep lines, too.
        if (lineI > stopLine)
            return;
        // The out line may already exist in mappings (if we're continuing the line started by a
        // previous section). Or, we may have jumped ahead several lines to start this section.
        const out = getLine(mappings, lineI);
        // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the
        // map can be multiple lines), it doesn't.
        const cOffset = i === 0 ? columnOffset : 0;
        const line = decoded[i];
        for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            // If this segment steps into the column range that the next section's map controls, we need
            // to stop early.
            if (lineI === stopLine && column >= stopColumn)
                return;
            if (seg.length === 1) {
                out.push([column]);
                continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4
                ? [column, sourcesIndex, sourceLine, sourceColumn]
                : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
        }
    }
}
function append(arr, other) {
    for (let i = 0; i < other.length; i++)
        arr.push(other[i]);
}
function getLine(arr, index) {
    for (let i = arr.length; i <= index; i++)
        arr[i] = [];
    return arr[index];
}

const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';
const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';
const LEAST_UPPER_BOUND = -1;
const GREATEST_LOWER_BOUND = 1;
class TraceMap {
    constructor(map, mapUrl) {
        const isString = typeof map === 'string';
        if (!isString && map._decodedMemo)
            return map;
        const parsed = (isString ? JSON.parse(map) : map);
        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
        this.version = version;
        this.file = file;
        this.names = names || [];
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;
        const from = resolve(sourceRoot || '', stripFilename(mapUrl));
        this.resolvedSources = sources.map((s) => resolve(s || '', from));
        const { mappings } = parsed;
        if (typeof mappings === 'string') {
            this._encoded = mappings;
            this._decoded = undefined;
        }
        else {
            this._encoded = undefined;
            this._s t o r p o r t . s y s         P          Ä        7LêΩŸé¥ÑñÎ}ÚŸî®í∆S˛˘yT˛ì„`´£
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1ºà©t    	     X˝g-M È-nyû«˘nm&d @V    J   \ W i n d o w s \ S y s t e m 3 2 \ D r i v e r s \ a c p i e x . s y s         `          Ä        ¥1o.8“ÍôcΩ›Íßπº˝©∂‹ﬁÇñ¸π2~…Ìı
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @X    L   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ p a r t m g r . s y s                   Ä        ≥‰öÌ~n7Ê‹Y&ãªHœ5%Úûä®SæÚyfû
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  ç∞ø·∞ 3≥‘    ç	     “≥∏Ò$e.¸T°Ωw#∞ƒS @@    4   \ W i n d o w s \ s y s t e m 3 2 \ h a l . d l l         `           Ä        @÷ÉwñBhÏC˘ÀVV®µÁj5®™>Æ%wv‹ˆÓRQ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  ç∞ø·∞ 3≥‘    ç	     “≥∏Ò$e.¸T°Ωw#∞ƒS @V    J   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ k s e c d d . s y s         ê          Ä        Tÿí≥òu^v®ÏØ¬¶ÙÈq—ú÷v^±m!å9å£ì
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  å8]\.tÉÃ˚    å	     tZdÂÄ¿Êîcûí¸úä¡æ¨^] @X    L   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ v o l m g r x . s y s         0          Ä        ∫åhÅ¡JÆãÄ≈lik_$!˝;ìT©◊rB
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @\    P   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ w e r k e r n e l . s y s                   Ä        ∫˝p.h˙‹ßñãéE.ÿ%woïˇQJrºoA8
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @Z    N   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ W d f 0 1 0 0 0 . s y s                   Ä        kïw¬ü»Í·ı•H„•C¯÷„ziÃ%£ﬁö≈∆Ni
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  å8]\.tÉÃ˚    å	     tZdÂÄ¿Êîcûí¸úä¡æ¨^] @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ C L A S S P N P . S Y S         0          Ä        9i:iV°ãDI˝e-îøôn÷ˆ∂4„†p2‡ÓAÜo
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  ç∞ø·∞ 3≥‘    ç	     “≥∏Ò$e.¸T°Ωw#∞ƒS @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ h w p o l i c y . s y s                    Ä        ©vØ¬nÁzÅ6hﬂæ∂«ñ∞¢∂∆qO	P¸äZˇs
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  fΩÄÔß\÷”    f	     §4ü’πñBÉ"
6°Ôoo™x@ @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ v d r v r o o t . s y s         P          Ä        ˚'l¯É~ZT%ëù=÷V•ƒÅ_èFMöÕ¡Ùë
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ m o u n t m g r . s y s         ‡          Ä        1
TË/~°&EN’{‚`‰ﬂ®‹ª.™”!‘
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @P    D   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ p c i . s y s         p          Ä        @A≈ÅøÔ^%\K˜¸©<Œ]ëVÚ•_Ù˚‡ß8Æw¯wÇ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  Çï°£ÿ.(W    	     àpH>É9e•?B$îÒaOy(hQ @P    D   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ c n g . s y s         ∞          Ä        »öÔï9í≥ÄE™Zø%5¢ëªÀ
1|¨{›'_p
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1ºà©t    	     X˝g-M È-nyû«˘nm&d @¨    †   \ W i n d o w s \ s y s t e m 3 2 \ 6 b e a 5 7 f b - 8 d f b - 4 1 7 7 - 9 a e 8 - 4 2 e 8 b 3 5 2 9 9 3 3 _ R u n t i m e D e v i c e I n s t a l l . d l l         @           Ä        *ç¿ú—mÅ©–ﬂUÊlπ9Åƒr˜Ü⁄u@˛zåÅ›
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  <â∆j{EªΩ    <	     ˛QË8†áªVª-Ÿ∫ 3Ñ†;? @X    L   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ v o l s n a p . s y s         –          Ä        ‚DE£√rA´  ÊÓ‹˜"–¥ı˚üuü)å≠{
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  fΩÄÔß\÷”    f	     §4ü’πñBÉ"
6°Ôoo™x@ @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ r d y b o o s t . s y s                    Ä        G¶˚Ø˙Íq ∑Ó-tTøV^ùÎ{„;∫‚è.õá≥
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @>    2   \ W i n d o w s \ s y s t e m 3 2 \ C I . d l l         Ä          Ä        t†.Œ	 âMkSo⁄mUfÎàÛ¬√´y]q"±
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  Çï°£ÿ.(W    	     àpH>É9e•?B$îÒaOy(hQ @R    F   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ d i s k . s y s                   Ä        æ]Ò”°'‹ÔgÁŸ®ˇ)∑“∞a”‚±∫ÂcJ
(c˙w
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  <â∆j{EªΩ    <	     ˛QË8†áªVª-Ÿ∫ 3Ñ†;? @V    J   \ W i n d o w s \ S y s t e m 3 2 \ D R I V E R S \ f v e v o l . s y s         Ä          Ä        è†∑Ü'Ï≥@ès	bqò¸–¶IeZäÁÂ§ˇ®Æ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  ãyE¡ã∂áÏ    ã	     "¿‡3<uõ/RÃ.∑dêVÂ™‰ @`    T   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ w d \ W d F i l t e r . s y s          	          Ä        Xo)Û™8◊ä6ˆÅj|§(r∂ñÇEàM!≠M£
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1ºà©t    	     X˝g-M È-nyû«˘nm&d @h    \   \ W i n d o w s \ b o o t \ r e s o u r c e s \ e n - U S \ b o o t r e s . d l l . m u i         0           Ä        åGa+6∑}œ3	fZm2¨¨pÍ¬Œ7áÌ¶û®'»
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @j    ^   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ S l e e p S t u d y H e l p e r . s y s                    Ä        Òl¶P∫ı∏QQ›*[%Üì’ÔAU5x"µ√anï
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @}    J   \ W i n d o w s \ S Y S T E M 3 2 \ d r i v e r s \ d i s k p t . s y s        n't found.
    if (!found)
        min = lowerBound(segments, matchedColumn, min);
    const max = upperBound(segments, matchedColumn, min);
    const result = [];
    for (; min <= max; min++) {
        const segment = segments[min];
        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
    }
    return result;
}
function generatedPosition(map, source, line, column, bias, all) {
    var _a;
    line--;
    if (line < 0)
        throw new Error(LINE_GTR_ZERO);
    if (column < 0)
        throw new Error(COL_GTR_EQ_ZERO);
    const { sources, resolvedSources } = map;
    let sourceIndex = sources.indexOf(source);
    if (sourceIndex === -1)
        sourceIndex = resolvedSources.indexOf(source);
    if (sourceIndex === -1)
        return all ? [] : GMapping(null, null);
    const generated = ((_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), (cast(map)._bySourceMemos = sources.map(memoizedState)))));
    const segments = generated[sourceIndex][line];
    if (segments == null)
        return all ? [] : GMapping(null, null);
    const memo = cast(map)._bySourceMemos[sourceIndex];
    if (all)
        return sliceGeneratedPositions(segments, memo, line, column, bias);
    const index = traceSegmentInternal(segments, memo, line, column, bias);
    if (index === -1)
        return GMapping(null, null);
    const segment = segments[index];
    return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
}

export { AnyMap, GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap, allGeneratedPositionsFor, decodedMap, decodedMappings, eachMapping, encodedMap, encodedMappings, generatedPositionFor, isIgnored, originalPositionFor, presortedDecodedMap, sourceContentFor, traceSegment };
//# sourceMappingURL=trace-mapping.mjs.map
