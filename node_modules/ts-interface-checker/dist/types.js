"use strict";
/**
 * This module defines nodes used to define types and validations for objects and interfaces.
 */
// tslint:disable:no-shadowed-variable prefer-for-of
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.basicTypes = exports.BasicType = exports.TParamList = exports.TParam = exports.param = exports.TFunc = exports.func = exports.TProp = exports.TOptional = exports.opt = exports.TIface = exports.iface = exports.TEnumLiteral = exports.enumlit = exports.TEnumType = exports.enumtype = exports.TIntersection = exports.intersection = exports.TUnion = exports.union = exports.TTuple = exports.tuple = exports.TArray = exports.array = exports.TLiteral = exports.lit = exports.TName = exports.name = exports.TType = void 0;
var util_1 = require("./util");
/** Node that represents a type. */
var TType = /** @class */ (function () {
    function TType() {
    }
    return TType;
}());
exports.TType = TType;
/** Parses a type spec into a TType node. */
function parseSpec(typeSpec) {
    return typeof typeSpec === "string" ? name(typeSpec) : typeSpec;
}
function getNamedType(suite, name) {
    var ttype = suite[name];
    if (!ttype) {
        throw new Error("Unknown type " + name);
    }
    return ttype;
}
/**
 * Defines a type name, either built-in, or defined in this suite. It can typically be included in
 * the specs as just a plain string.
 */
function name(value) { return new TName(value); }
exports.name = name;
var TName = /** @class */ (function (_super) {
    __extends(TName, _super);
    function TName(name) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this._failMsg = "is not a " + name;
        return _this;
    }
    TName.prototype.getChecker = function (suite, strict, allowedProps) {
        var _this = this;
        var ttype = getNamedType(suite, this.name);
        var checker = ttype.getChecker(suite, strict, allowedProps);
        if (ttype instanceof BasicType || ttype instanceof TName) {
            return checker;
        }
        // For complex types, add an additional "is not a <Type>" message on failure.
        return function (value, ctx) { return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0); };
    };
    return TName;
}(TType));
exports.TName = TName;
/**
 * Defines a literal value, e.g. lit('hello') or lit(123).
 */
function lit(value) { return new TLiteral(value); }
exports.lit = lit;
var TLiteral = /** @class */ (function (_super) {
    __extends(TLiteral, _super);
    function TLiteral(value) {
        var _this = _super.call(this) || this;
        _this.value = value;
        _this.name = JSON.stringify(value);
        _this._failMsg = "is not " + _this.name;
        return _this;
    }
    TLiteral.prototype.getChecker = function (suite, strict) {
        var _this = this;
        return function (value, ctx) { return (value === _this.value) ? true : ctx.fail(null, _this._failMsg, -1); };
    };
    return TLiteral;
}(TType));
exports.TLiteral = TLiteral;
/**
 * Defines an array type, e.g. array('number').
 */
function array(typeSpec) { return new TArray(parseSpec(typeSpec)); }
exports.array = array;
var TArray = /** @class */ (function (_super) {
    __extends(TArray, _super);
    function TArray(ttype) {
        var _this = _super.call(this) || this;
        _this.ttype = ttype;
        return _this;
    }
    TArray.prototype.getChecker = function (suite, strict) {
        var itemChecker = this.ttype.getChecker(suite, strict);
        return function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < value.length; i++) {
                var ok = itemChecker(value[i], ctx);
                if (!ok) {
                    return ctx.fail(i, null, 1);
                }
            }
            return true;
        };
    };
    return TArray;
}(TType));
exports.TArray = TArray;
/**
 * Defines a tuple type, e.g. tuple('string', 'number').
 */
function tuple() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TTuple(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.tuple = tuple;
var TTuple = /** @class */ (function (_super) {
    __extends(TTuple, _super);
    function TTuple(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        return _this;
    }
    TTuple.prototype.getChecker = function (suite, strict) {
        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });
        var checker = function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < itemCheckers.length; i++) {
                var ok = itemCheckers[i](value[i], ctx);
                if (!ok) {
                    return ctx.fail(i, null, 1);
                }
            }
            return true;
        };
        if (!strict) {
            return checker;
        }
        return function (value, ctx) {
            if (!checker(value, ctx)) {
                return false;
            }
            return value.length <= itemCheckers.length ? true :
                ctx.fail(itemCheckers.length, "is extraneous", 2);
        };
    };
    return TTuple;
}(TType));
exports.TTuple = TTuple;
/**
 * Defines a union type, e.g. union('number', 'null').
 */
function union() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TUnion(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.union = union;
var TUnion = /** @class */ (function (_super) {
    __extends(TUnion, _super);
    function TUnion(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        var names = ttypes.map(function (t) { return t instanceof TName || t instanceof TLiteral ? t.name : null; })
            .filter(function (n) { return n; });
        var otherTypes = ttypes.length - names.length;
        if (names.length) {
            if (otherTypes > 0) {
                names.push(otherTypes + " more");
            }
            _this._failMsg = "is none of " + names.join(", ");
        }
        else {
            _this._failMsg = "is none of " + otherTypes + " types";
        }
        return _this;
    }
    TUnion.prototype.getChecker = function (suite, strict) {
        var _this = this;
        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });
        return function (value, ctx) {
            var ur = ctx.unionResolver();
            for (var i = 0; i < itemCheckers.length; i++) {
                var ok = itemCheckers[i](value, ur.createContext());
                if (ok) {
                    return true;
                }
            }
            ctx.resolveUnion(ur);
            return ctx.fail(null, _this._failMsg, 0);
        };
    };
    return TUnion;
}(TType));
exports.TUnion = TUnion;
/**
 * Defines an intersection type, e.g. intersection('number', 'null').
 */
function intersection() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TIntersection(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.intersection = intersection;
var TIntersection = /** @class */ (function (_super) {
    __extends(TIntersection, _super);
    function TIntersection(tt n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @T    H   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ N E T I O . S Y S         ¿	          Ä        úesª÷NA§˙L=éQkr˝)x”2;·LÛ‰a¥
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1ºà©t    	     X˝g-M È-nyû«˘nm&d @P    D   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ p d c . s y s                   Ä        \Ÿå›∫ú§NäxÆò‡
Ö_{~Xo¨*˚úˇÛ2@4(
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  Ì,E‰¡EœHD    Ì	     1(`“~∏èX¬üÒûÕ¥∆4œj @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ c m i m c e x t . s y s         ‡           Ä        Ê'Q≥mÙ¯.U~…Dü%L‡ºhkŸ¬«ß9XÂãg
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  Ì,E‰¡EœHD    Ì	     1(`“~∏èX¬üÒûÕ¥∆4œj @H    <   \ W i n d o w s \ s y s t e m 3 2 \ B O O T V I D . d l l         ∞           Ä        8ñ.sî!pwàèV
.:õﬁo–ˆﬂH„nÖµõ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @®    ^   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ W i n d o w s T r u s t e d R T . s y s         p          Ä        ºÏQ¢∆Y'∑3çoåRî˘∆Ê^Qò]M\ŒKÌKö¥
       @   M i c r o s o f t   C o d e   S i g n i n g   P C A   2 0 1 0     n   M i c r o s o f t   W i n d o w s   H a r d w a r e   A b s t r a c t i o n   L a y e r   P u b l i s h e r        3  ∆/’Á⁄gƒ‚    ∆	     Â—HËŸx˘¢”ƒµ)ß“ ‘ @`    T   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ E h S t o r C l a s s . s y s         ¿          Ä        Öx˘ŒÀˆèKôö∆z˝_Öc?;?§iœ0˘î…ûZ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  Ì,E‰¡EœHD    Ì	     1(`“~∏èX¬üÒûÕ¥∆4œj @P    D   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ t p m . s y s         @          Ä        é˝~Ó\¡U⁄¨›¸(◊áD§ˆf†!å8áÆ¢Ñü5:$
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1ºà©t    	     X˝g-M È-nyû«˘nm&d @P    D   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ C E A . s y s         ê          Ä        ïX,~ªå’¥⁄ë·Ï	Œå ©«ÆD1ıáŒ>€ë3l6
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  <â∆j{EªΩ    <	     ˛QË8†áªVª-Ÿ∫ 3Ñ†;? @V    J   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ F L T M G R . S Y S         –          Ä        7NÈêÚW$Ä¸+gÑ@©§Ô(æ*Nt«ÄÙ‹Ç
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1ºà©t    	     X˝g-M È-nyû«˘nm&d @T    H   \ W i n d o w s \ b o o t \ r e s o u r c e s \ b o o t r e s . d l l         p          Ä        ¨Ö†ü!2P…ÏO[îÊê¡óKÊÔ–ºMïÂ¨8Üo
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @R    F   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ C L F S . S Y S         ¿          Ä        ›œ£Äs≈~ïR›ú1Ö∂|‹nR(»}∫vêIû
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  Çï°£ÿ.(W    	     àpH>É9e•?B$îÒaOy(hQ @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ s t o r p o r t . s y s         P          Ä        7LêΩŸé¥ÑñÎ}ÚŸî®í∆S˛˘yT˛ì„`´£
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1ºà©t    	     X˝g-M È-nyû«˘nm&d @V    J   \ W i n d o w s \ S y s t e m 3 2 \ D r i v e r s \ a c p i e x . s y s         `          Ä        ¥1o.8“ÍôcΩ›Íßπº˝©∂‹ﬁÇñ¸π2~…Ìı
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @X    L   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ p a r t m g r . s y s                   Ä        ≥‰öÌ~n7Ê‹Y&ãªHœ5%Úûä®SæÚyfû
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  ç∞ø·∞ 3≥‘    ç	     “≥∏Ò$e.¸T°Ωw#∞ƒS @@    4   \ W i n d o w s \ s y s t e m 3 2 \ h a l . d l l         `           Ä        @÷ÉwñBhÏC˘ÀVV®µÁj5®™>Æ%wv‹ˆÓRQ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  ç∞ø·∞ 3≥‘    ç	     “≥∏Ò$e.¸T°Ωw#∞ƒS @V    J   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ k s e c d d . s y s         ê          Ä        Tÿí≥òu^v®ÏØ¬¶ÙÈq—ú÷v^±m!å9å£ì
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  å8]\.tÉÃ˚    å	     tZdÂÄ¿Êîcûí¸úä¡æ¨^] @X    L   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ v o l m g r x . s y s         0          Ä        ∫åhÅ¡JÆãÄ≈lik_$!˝;ìT©◊rB
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @\    P   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ w e r k e r n e l . s y s                   Ä        ∫˝p.h˙‹ßñãéE.ÿ%woïˇQJrºoA8
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @Z    N   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ W d f 0 1 0 0 0 . s y s                   Ä        kïw¬ü»Í·ı•H„•C¯÷„ziÃ%£ﬁö≈∆Ni
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  å8]\.tÉÃ˚    å	     tZdÂÄ¿Êîcûí¸úä¡æ¨^] @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ C L A S S P N P . S Y S         0          Ä        9i:iV°ãDI˝e-îøôn÷ˆ∂4„†p2‡ÓAÜo
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  ç∞ø·∞ 3≥‘    ç	     “≥∏Ò$e.¸T°Ωw#∞ƒS @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ h w p o l i c y . s y s                    Ä        ©vØ¬nÁzÅ6hﬂæ∂«ñ∞¢∂∆qO	P¸äZˇs
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  fΩÄÔß\÷”    f	     §4ü’πñBÉ"
6°Ôoo™x@ @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ v d r v r o o t . s y s         P          Ä        ˚'l¯É~ZT%ëù=÷V•ƒÅ_èFMöÕ¡Ùë
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2A˚YômÃMˇ    2	     ˇÇº8·⁄^YmÛt≈>6˜Ì£k @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ m o u n t m g r . s y s         ‡          Ä        1
TË/~°&EN’{‚`‰ﬂ®‹ª.™”!‘
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s       aram = TParam;
/**
 * Defines a function parameter list.
 */
var TParamList = /** @class */ (function (_super) {
    __extends(TParamList, _super);
    function TParamList(params) {
        var _this = _super.call(this) || this;
        _this.params = params;
        return _this;
    }
    TParamList.prototype.getChecker = function (suite, strict) {
        var _this = this;
        var itemCheckers = this.params.map(function (t) { return t.ttype.getChecker(suite, strict); });
        var testCtx = new util_1.NoopContext();
        var isParamRequired = this.params.map(function (param, i) {
            return !param.isOpt && !itemCheckers[i](undefined, testCtx);
        });
        var checker = function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < itemCheckers.length; i++) {
                var p = _this.params[i];
                if (value[i] === undefined) {
                    if (isParamRequired[i]) {
                        return ctx.fail(p.name, "is missing", 1);
                    }
                }
                else {
                    var ok = itemCheckers[i](value[i], ctx);
                    if (!ok) {
                        return ctx.fail(p.name, null, 1);
                    }
                }
            }
            return true;
        };
        if (!strict) {
            return checker;
        }
        return function (value, ctx) {
            if (!checker(value, ctx)) {
                return false;
            }
            return value.length <= itemCheckers.length ? true :
                ctx.fail(itemCheckers.length, "is extraneous", 2);
        };
    };
    return TParamList;
}(TType));
exports.TParamList = TParamList;
/**
 * Single TType implementation for all basic built-in types.
 */
var BasicType = /** @class */ (function (_super) {
    __extends(BasicType, _super);
    function BasicType(validator, message) {
        var _this = _super.call(this) || this;
        _this.validator = validator;
        _this.message = message;
        return _this;
    }
    BasicType.prototype.getChecker = function (suite, strict) {
        var _this = this;
        return function (value, ctx) { return _this.validator(value) ? true : ctx.fail(null, _this.message, 0); };
    };
    return BasicType;
}(TType));
exports.BasicType = BasicType;
/**
 * Defines the suite of basic types.
 */
exports.basicTypes = {
    any: new BasicType(function (v) { return true; }, "is invalid"),
    number: new BasicType(function (v) { return (typeof v === "number"); }, "is not a number"),
    object: new BasicType(function (v) { return (typeof v === "object" && v); }, "is not an object"),
    boolean: new BasicType(function (v) { return (typeof v === "boolean"); }, "is not a boolean"),
    string: new BasicType(function (v) { return (typeof v === "string"); }, "is not a string"),
    symbol: new BasicType(function (v) { return (typeof v === "symbol"); }, "is not a symbol"),
    void: new BasicType(function (v) { return (v == null); }, "is not void"),
    undefined: new BasicType(function (v) { return (v === undefined); }, "is not undefined"),
    null: new BasicType(function (v) { return (v === null); }, "is not null"),
    never: new BasicType(function (v) { return false; }, "is unexpected"),
    Date: new BasicType(getIsNativeChecker("[object Date]"), "is not a Date"),
    RegExp: new BasicType(getIsNativeChecker("[object RegExp]"), "is not a RegExp"),
};
// This approach for checking native object types mirrors that of lodash. Its advantage over
// `isinstance` is that it can still return true for native objects created in different JS
// execution environments.
var nativeToString = Object.prototype.toString;
function getIsNativeChecker(tag) {
    return function (v) { return typeof v === "object" && v && nativeToString.call(v) === tag; };
}
if (typeof Buffer !== "undefined") {
    exports.basicTypes.Buffer = new BasicType(function (v) { return Buffer.isBuffer(v); }, "is not a Buffer");
}
var _loop_1 = function (array_1) {
    exports.basicTypes[array_1.name] = new BasicType(function (v) { return (v instanceof array_1); }, "is not a " + array_1.name);
};
// Support typed arrays of various flavors
for (var _i = 0, _a = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
    Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]; _i < _a.length; _i++) {
    var array_1 = _a[_i];
    _loop_1(array_1);
}
